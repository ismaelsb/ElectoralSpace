{
    "contents" : "#Install ggtern from an online CRAN repository\ninstall.packages(\"ggtern\")\n#Load the ggtern library\nlibrary(ggtern)\n#library(stats)\nset.seed(156) #fix random generation\n\ngenerateNodes <- function(seats){ \n  \n  #define nodes\n  nnodes = (seats+1)*(seats+2)/2;\n  nodes  = matrix(0,nnodes,3);\n  t=1;\n  for (i in 0:seats){\n    for (j in i:seats){\n      nodes[t,] = c(i,j-i,seats-j);\n      t=t+1;\n    }\n  }  \n  \n  index=as.matrix(1:nnodes)\n  \n  #node labels for seats\n  label=cbind(as.character(nodes[,1]),matrix(\"-\",nnodes),as.character(nodes[,2]),matrix(\"-\",nnodes),as.character(nodes[,3]))\n  label=do.call(\"paste0\",as.data.frame(label))\n  \n  \n  nodes <- cbind(index,as.data.frame(nodes),label)\n  names(nodes) <- c(\"index\",letters[24:26],\"label\")\n  return(nodes);\n  \n}\n\ngenerateColors <- function (colorRGB, seats) {\n  \n  nnodes = (seats+1)*(seats+2)/2;\n  nodes <- as.matrix(generateNodes(seats)[,c(\"x\",\"y\",\"z\")])\n  #decimal codes for colors in nodes\n  Code3 = floor(nodes*255.9/seats) #255.9 avoids seats -> 256 -> HEX #100 case\n  #linear transformation to fixed extreme colors\n  CodeDecRGB = floor(Code3%*%matrix(colorRGB,3,3, byrow=T)/256)\n  #hex codes for colors in nodes\n  CodeRGB=cbind(matrix(\"#\",nnodes),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))\n  CodeRGB=do.call(\"paste0\",as.data.frame(CodeRGB))\n  values=CodeRGB\n  \n  return(values);\n  \n}\n\nalloc <- function(parties, votes, seats, step, threshold=0){\n  \n  #function for the seat allocation and its ordering\n  #computes allocation for several values of seats and divisor step methods\n  #with the same quotiens table\n  votes=votes*(votes>=(threshold*sum(votes)))\n  Mst <- max(step)\n  Mse <- max(seats)\n  nquotients=(1+Mst*(Mse-1))\n  \n  #table with all the quotients needed\n  quotienstable <- data.frame( \n    parties    = rep(parties, each = nquotients), \n    quotients  = as.vector(sapply(votes, function(x) \n      x/seq(from=1, to=nquotients) )),\n    votesrep   = rep(votes, each = nquotients)\n  ) \n  \n  SeatsList=list()\n  filteredtable =list()\n  \n  \n  for (j in 1:length(step)) {\n    \n    \n    #select from the table of all quotiens the ones whose divisors\n    #belong to the current sequence, given 'seats' and 'step'\n    select <- rep(seq(from=1, to=1+step[j]*(Mse-1), by=step[j]),length(parties))+\n      rep(seq(from=0,to=nquotients*length(parties)-1,by=nquotients),each=Mse)\n    \n    filteredtable [[j]] <- quotienstable$parties[select][order(-quotienstable$quotients[select], -quotienstable$votesrep[select])]\n    \n    SeatsList[[j]]<-list()\n    \n    #a vector of values for seats if you want to compute the partial sums\n    for (i in 1:length(seats)){\n      SeatsList[[j]][[i]]= table(filteredtable[[j]][1:seats[i]])\n    }\n    \n    names(SeatsList[[j]])[1:length(seats)]<-do.call(\"paste0\",as.data.frame(cbind(\"divisor step \",step[j],\" for \", seats,\" seats\")))\n    \n    \n    SeatsList[[j]][[length(seats)+1]] = as.matrix(filteredtable[[j]][1:Mse]) #ordering\n    \n    names(SeatsList[[j]])[length(seats)+1]<-paste0(\"ordering for divisor step \", step[j],\" for \", Mse,\" seats\")\n    \n    \n  }\n  \n  \n  return(SeatsList);\n  \n}\n\ngenerateDots <- function(dotsperside, method=\"lattice\"){\n  \n  dots <- (dotsperside+1)*(dotsperside+2)/2\n  \n  if (method == \"cartesian\") {\n    #Map Cartesian to Ternary to produce a homegeneous simulation\n    Rc = matrix(runif(2*dots), nrow=dots, ncol=2)\n    R  = matrix(apply(Rc,1, CartesianToTernary), nrow=dots, ncol=3, byrow=TRUE)\n  }\n  \n  else if (method == \"ternary\") {\n    #Ternary simulation. Projects points in[0,1]^3 to the sum(x)=1 hyperplane\n    #This creates way more points in the center than in the extremes\n    R = matrix(runif(3*dots), nrow=dots, ncol=3)\n    R = prop.table(R,1) #rows sum 1\n  }\n  \n  else if (method == \"lattice\") {\n    #lattice of dots\n    \n    #read this if you want to use dots instead of dotsperside as input variable:\n    #if n is dotsperside\n    #dots <- (n+1)*(n+2)/2  \n    #inverse calculation:\n    #n <- floor((sqrt(8*dots+1)-3)/2) #exact\n    #n <- floor(sqrt(2*dots)) #aprox\n    \n    #then redefine number of dots\n    #dots <- (n+1)*(n+2)/2\n    R <- matrix(0,nrow=dots, ncol=3)\n    i <- 1\n    for (x in 0:dotsperside){\n      \n      for (y in 0:(dotsperside-x)){\n        \n        R[i,]<- c(x,y,dotsperside-x-y)\n        i <- i+1\n        \n      }\n    }\n    R = prop.table(R,1) #rows sum 1\n  }\n  \n  return(R);\n  \n}\n\nCartesianToTernary <- function (x) {\n  \n  #for homogeneous simulation\n  #send an subset of [0,1]x[0,1] which is an equilateral triangle to the ternary diagram \n  \n  while ((x[1]<=1/2 & x[2]>2*sin(pi/3)*x[1]) | (x[1]>1/2 & x[2]>2*sin(pi/3)*(1-x[1])))\n    x=runif(2);\n  \n  v = cbind(1-x[1]-x[2]/(2*sin(pi/3)),x[2]/sin(pi/3),x[1]-x[2]/(2*sin(pi/3)));\n  \n  return(v);\n  \n}\n\nUniformNearest <- function (x, seats, nodes, nnodes) {\n  \n  Uniform = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,max))\n  \n  return(Uniform);\n  \n}\n\nManhattanNearest <- function (x, seats, nodes, nnodes) {\n  \n  Manhattan = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,sum))\n  \n  return(Manhattan);\n  \n}\n\nEuclidNearest <- function (x, seats, nodes, nnodes) {\n  \n  Euclid = which.min(apply((nodes/seats - rep(1,nnodes) %*% t(x))^2,1,sum))\n  \n  return(Euclid);\n  \n}\n\nAllocatedNode <- function (y, nodes, nnodes) {\n  \n  Node = which.min(apply(abs(nodes - rep(1,nnodes) %*% t(y)),1,max))\n  \n  return(Node);\n  \n}\n\nSpatialData <- function (dotsperside, seats, step=1, threshold=0, method=\"lattice\") {\n  \n  \n  #Generate random electoral results\n  R <- generateDots(dotsperside, method=method)\n  dots=dim(R)[1]  #dots <- (dotsperside+1)*(dotsperside+2)/2\n  \n  Seats=max(seats)\n  \n  #nodes\n  nodes  <- as.matrix(generateNodes(Seats)[,c(\"x\",\"y\",\"z\")])\n  nnodes <- (Seats+1)*(Seats+2)/2;\n  \n  #Indexes for Voronoi regions\n  Uniform   = apply(R, 1, UniformNearest,   seats=Seats, nodes = nodes, nnodes=nnodes)\n  Manhattan = apply(R, 1, ManhattanNearest, seats=Seats, nodes = nodes, nnodes=nnodes)\n  Euclid    = apply(R, 1, EuclidNearest,    seats=Seats, nodes = nodes, nnodes=nnodes)\n  \n  #allocate seats\n  AllocStructure <- apply(R, 1, function(x) alloc(as.character(1:3), x, seats, step, threshold))\n  #input a vector of values for seats of to compute partial sums\n  \n  df=list() #list of dataframes, one for each 'step' value\n  \n  #loop for diferent 'step's\n  for (j in 1:length(step)){\n    \n    #allocation\n    AllocPartial=matrix(0,dots,length(seats))\n    \n    for (i in 1:length(seats)){\n      \n      S = t(matrix(sapply(AllocStructure, function(x) x[[j]][[i]]),nrow=3,ncol=dots))\n      \n      nodes_sub <- as.matrix(generateNodes(seats[i])[,c(\"x\",\"y\",\"z\")])\n      \n      AllocPartial[,i] = apply(S, 1, AllocatedNode, nodes=nodes_sub, nnodes=(seats[i]+1)*(seats[i]+2)/2)\n      \n    }\n    \n    #allocation order\n    #computes allocation ordering for max(seats) in each step value\n    AllocOrder = t(matrix(sapply(AllocStructure, function(x) as.integer(x[[j]][[length(seats)+1]])),nrow=Seats,ncol=dots))\n    vectorOrderCode=as.matrix(3^(0:(Seats-1)))\n    #this coding highlights the last seats over the first ones\n    # so that there is contrast between adjacent regions\n    AllocOrderCode = (matrix(AllocOrder, ncol=Seats)-1) %*% as.matrix(vectorOrderCode)\n    \n    dfPartial=as.data.frame(AllocPartial)\n    names(dfPartial) <- do.call(paste0,as.data.frame(cbind(\"All\",seats)))\n    names(dfPartial)[which(seats==Seats)] <- \"Allocated\"\n    \n    #assembling a data frame\n    df0 = data.frame(\n      \n      \n      x             = as.matrix(R[,1]),\n      y             = as.matrix(R[,2]),\n      z             = as.matrix(R[,3]),\n      \n      Sx            = S[,1],\n      Sy            = S[,2],\n      Sz            = S[,3],\n      \n      Euclid,\n      Manhattan,\n      Uniform,\n      \n      Malapportionment = AllocPartial[1:dots,length(seats)] != Euclid[1:dots],\n      \n      AllocOrderCode\n      \n      \n    )\n    \n    df0=cbind(df0,dfPartial)\n    \n    df[[j]]<-df0\n    \n  } #end of loop for different 'step's\n  \n  \n  return(df);\n  \n}\n\ngenerateOrderColors <- function (colorRGB, seats, validCodes=TRUE) {\n  \n  #generate order color from alloc order codes\n  \n  #extract allocation order from allocation order codes:\n  OrderCode <-as.matrix(0:(3^seats-1))\n  \n  OrderRests <- t(matrix(apply(OrderCode, 1, function(x) x %% (3^(1:seats))),ncol=3^seats, nrow=seats))\n  #(this is vectorial for OrderRests <- OrderCode %% (3^(1:seats))  )\n  \n  Order_from_code <- (cbind(OrderRests,0)-cbind(0,OrderRests))[,1:seats]/t(matrix(rep(3^(0:(seats-1)),3^seats),ncol=3^seats,nrow=seats))+1\n  vectorOrderCode3 <- 2^(0:(seats-1))\n  #decimal codes for colors in nodes\n  Code3 = cbind((Order_from_code == 1)%*%as.matrix(vectorOrderCode3),\n                (Order_from_code == 2)%*%as.matrix(vectorOrderCode3),\n                (Order_from_code == 3)%*%as.matrix(vectorOrderCode3))\n  \n  #linear transformation to fixed extreme colors\n  CodeDecRGB = floor(Code3%*%matrix(colorRGB,3,3, byrow=T)/2^seats)\n  \n  #hex codes for colors in nodes\n  CodeRGB = cbind(matrix(\"#\",3^seats),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))\n  CodeRGB = do.call(\"paste0\",as.data.frame(CodeRGB))\n  \n  #values = CodeRGB[validCodes]\n  values = CodeRGB[c(validCodes, 3^seats)] #added one more color bc scale_color_manual() demanded one more color\n  #values = CodeRGB[c(1, validCodes)] #added one more color bc scale_color_manual() demanded one more color\n  \n  \n  return(values);\n  \n}\n\nVotesData <- function (votes=matrix(0,1), election=matrix(0,1)) {\n  \n  votes <- prop.table(votes,1)  \n  \n  x <- votes[,1]\n  y <- votes[,2]\n  z <- votes[,3]\n  \n  el=dim(votes)[1]\n  label = as.character(election)\n  \n  \n  #assembling a data frame\n  df = data.frame(\n    \n    type = matrix(\"vote\",el,1),\n    \n    x ,\n    y ,\n    z ,\n    \n    label,\n    \n    election,\n    \n    color = matrix(NA,el,1)\n    \n  )\n  \n  return(df);\n  \n}\n\ngenerateSpline <- function (dfvotes, method = \"natural\") {\n  \n  #generates a spline curve through elections history\n  \n  nelect = dim(dfvotes)[1]\n  \n  splineX <- spline(x=1:nelect,y=dfvotes$x, method=method)\n  splineY <- spline(x=1:nelect,y=dfvotes$y, method=method)\n  \n  dfSpline = matrix(0, length(splineX[[1]]), 3)\n  dfSpline[,1] <- splineX[[2]]\n  dfSpline[,2] <- splineY[[2]]\n  dfSpline[,3] <- 1-dfSpline[,1]-dfSpline[,2]\n  dfSpline = as.data.frame(dfSpline)\n  names(dfSpline) <- letters[24:26]\n  \n  return(dfSpline);\n  \n}\n\n\n\n#plot example\nggtern(data=data.frame(x=0.2,y=0.3,z=0.5),aes(x,y,z))+\n  theme_arrowdefault()+geom_point()\n\n#colors for palettes\ncolorRGB1 <- c(242,74,87, 124,218,198, 91,168,246) #c(\"#f24a57\",\"#7cdac6\",\"#5ba8f6\")\ncolorRGB2 <- c(226,10,23, 100,207,151, 0,112,184) #c(\"#e20a17\",\"#64cf97\",\"#0070b8\")\ncolorRGB3 <- c(242,74,87, 124,218,198, 2,114,195) #<--\ncolorRGB4 <- c(256,0,0, 0,256,0, 0,0,256)\ncolorRGB5 <- c(224,0,0, 96,224,176, 96,128,224)\ncolorRGB5 <- c(240,0,0, 96,224,176, 96,128,224)\ncolorRGB6 <- c(256,256,0, 0,256,256, 256,0,256) ##YMC test shifted colours\ncolorRGB7 <- c(256,256,256, 256,0,0, 0,0,0) #WRB\n\ncolorRGB0 <- colorRGB3 #choose color palette\n\nseats=5\nNodesData <- generateNodes(max(seats))\n\n#plot nodes for seat allocation\nggtern(data=NodesData,aes(x,y,z,color=as.factor(index)))+\n  theme_minimal()+\n  geom_point(alpha=1, size=5)+\n  geom_text(aes(label=label,color=as.factor(index)), hjust=0.5, vjust=-0.6, size=4)+ \n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Nodes for seat allocation\")+\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\n  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value=\"khaki2\")\n\n\n#Allocation example (step=2 Sainte-Lagu?; step=1 D'Hondt)\nvotes <- sample(1:1000, 3) \nvotes\n#alloc(letters[1:3], votes, seats=5, step=1)\n#alloc(letters[1:3], votes, seats=c(3,5,4), step=c(2,1), threshold=0.5)\nalloc(letters[1:3], votes, 9, c(1,2), .05) #print seats sum and allocation\n\n\n#presets\nseats=2:5;\nstep=c(1,2); #(2 Sainte-Lagu? 1 D'Hondt)\ndotsperside=199 #dots <- (dotsperside+1)*(dotsperside+2)/2\nthreshold=0\n\n#Spatial data\n\ndots <- (dotsperside+1)*(dotsperside+2)/2\n\ndf = SpatialData(dotsperside, seats, step)\n\n#df = SpatialData(dotsperside, 5, 1, threshold)\n\n#df = SpatialData(dotsperside, c(3,5,4), c(2,1), threshold)\n\ndfT = SpatialData(dotsperside, seats=5, threshold=.20)\n\n\nhead(df[[1]][sample(1:dots,10,replace=F),]) #sample data for step=1 and seats=5\n\n\n\n#Allocation\n\na1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Allocated)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"D'Hondt Allocation\")+\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\n  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value=\"khaki2\")\n\na2 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(Allocated)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Sainte-Lagu? Allocation\")+\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\n  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value=\"khaki2\")\n\nggtern.multi(a1, a2, cols=2)\n\n#Voronoi\n\na3 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Manhattan)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Voronoi Allocation\")+\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\n  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value=\"khaki2\")\n\nggtern.multi(a2, a3, cols=2)\n\n#equivalence between Voronoi regions using different distances and between those and electoral regions\nsum(df[[1]]$Euclid[1:dots]==df[[1]]$Manhattan[1:dots])/dots\nsum(df[[1]]$Uniform[1:dots]==df[[1]]$Manhattan[1:dots])/dots\nsum(df[[1]]$Uniform[1:dots]==df[[1]]$Euclid[1:dots])/dots\n\n#size of the regions # 1 ~= dots/nnodes\nnnodes=(max(seats)+1)*(max(seats)+2)/2;\nRegionSize  = table(df[[1]]$Allocated[1:dots])/(dots/nnodes)\nRegionSize2 = table(df[[2]]$Allocated[1:dots])/(dots/nnodes)\n\npar(mfrow=c(2,1))\nplot(RegionSize, main=\"D'Hondt region sizes\")\nplot(RegionSize2,main=\"Sainte-Lagu? region sizes\" )\npar(mfrow=c(1,1))\n\n\n#malapportionment\nm1 <- ggtern(data=df[[1]],aes(x,y,z,color=Malapportionment)) +\n  theme_rgbw() +\n  geom_point(alpha=0.8) +\n  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color=\"grey60\")+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"D'Hondt Malapportionment\")+\n  #scale_colour_grey(na.value = \"black\", guide = FALSE)\n  scale_colour_brewer(palette = \"YlGnBu\", na.value = \"grey60\", guide = FALSE)\n\nm2 <- ggtern(data=df[[2]],aes(x,y,z,color=Malapportionment)) +\n  theme_rgbw() +\n  geom_point(alpha=0.8) +\n  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color=\"grey60\")+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Sainte-Lagu? Malapportionment\")+\n  scale_colour_brewer(palette = \"YlGnBu\", na.value = \"grey60\", guide = FALSE)\n\nggtern.multi(m1, m2, cols=2)\n\n#points not allocated by D'Hondt in their corresponding Voronoi region\nsum(df[[1]]$Malapportionment[1:dots])/dots\n#points not allocated by Sainte-Lagu? in their corresponding Voronoi region\nsum(df[[2]]$Malapportionment[1:dots])/dots\n\n#Threshold effect\nt1 <- ggtern(data=dfT[[1]],aes(x,y,z,color=as.factor(Allocated)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Threshold effect on regions\")+\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\n  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value=\"khaki2\")\n\nggtern.multi(a1, t1, cols=2)\n\n\n#ordering subregions\no1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(AllocOrderCode))) +\n  theme_bw()+\n  geom_point(alpha=0.8) +\n  geom_point(data=NodesData,aes(x,y,z),color=\"black\")+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Allocation ordering regions\")+\n  scale_colour_grey(start = 0.1, end = 1, na.value = \"black\", guide = FALSE)\n\no2 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(AllocOrderCode))) +\n  theme_bw()+\n  geom_point(alpha=1) +\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"They come in colors\")+\n  scale_colour_manual(values=\n      generateOrderColors(colorRGB0,max(seats),sort(unique(df[[1]]$AllocOrderCode))),\n      guide=FALSE, na.value=\"khaki2\")\n\nggtern.multi(o1, o2, cols=2)\n\n#Partial Allocations\n\np1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(df[[1]]$All2)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"D'Hondt, 2 seats\")+\n  scale_colour_manual(values=generateColors(colorRGB0,2), guide=FALSE)\n\np2 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(df[[1]]$All3)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"D'Hondt, 3 seats\")+\n  scale_colour_manual(values=generateColors(colorRGB0,3), guide=FALSE)\n\np3 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(df[[1]]$All4)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"D'Hondt, 4 seats\")+\n  scale_colour_manual(values=generateColors(colorRGB0,4), guide=FALSE)\n\np4 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(df[[2]]$All2)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Sainte-Lagu?, 2 seats\")+\n  scale_colour_manual(values=generateColors(colorRGB0,2), guide=FALSE)\n\np5 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(df[[2]]$All3)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Sainte-Lagu?, 3 seats\")+\n  scale_colour_manual(values=generateColors(colorRGB0,3), guide=FALSE)\n\np6 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(df[[2]]$All4)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Sainte-Lagu?, 4 seats\")+\n  scale_colour_manual(values=generateColors(colorRGB0,4), guide=FALSE)\n\nplist=list(p1,p4,p2,p5,p3,p6)\nggtern.multi(plotlist=plist, cols=3)\n\n\n\n#history of election results\n\n\n#nelect=10;\n#votes=matrix(runif(nelect*3),nelect,3)\n#votes <- prop.table(votes,1)\n\nelection=as.matrix(seq(from=1979, to=2015, by=4))\n\n#example\n#seats=5; step=1;\nnelect=10;\nvotes=matrix(0,nelect,3)\nvotes[,1]=c(350,430,290,400,390,450,470,360,280,230)\nvotes[,3]=c(250,180,220,160,140,110, 80, 60, 90,140)\nvotes[,2]=c( 80, 90,130, 70, 90, 80,120,140,130,110)\n\n#votes[,1]=c(355,437,282,393,408,479,468,356,287,234)\n#votes[,3]=c(258,  0,185,144,159, 90, 47, 73,114, 75)\n#votes[,2]=c(  0,  0, 82,  0,  0,  0,  0,  0,  0,138)\n\ndfvotes <- VotesData(votes=votes, election=election)\n\ndfSpline <- generateSpline(dfvotes)\n\nggtern(data=df[[1]],aes(x,y,z,color=as.factor(Allocated)))+\n  #theme_rgbw()+\n  theme_bw()+\n  geom_point(alpha=1)+\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\n  geom_point(data=dfvotes,aes(x,y,z),color=\"orange\",alpha=1)+\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \n  geom_text(data=dfvotes,aes(label=label), color=\"slateblue4\", hjust=1.2, vjust=0.3, size=3, angle=90)+ \n  geom_path(data=dfSpline,colour=\"darkgreen\", linetype=1, size=1)+ \n  #geom_path(data=dfvotes,colour=\"white\", linetype=1, size=0.7)+ \n  labs(x=\"SocLib\",y=\"SocCom\",z=\"LibCon\",title=\"Past Elections\")+\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\n  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value=\"khaki2\")\n\n\n\n#other colour palettes\nlibrary(RColorBrewer)\n# RdYlGn 11\n# Spectral 11\n# YlGnBu 9\nvalues=colorRampPalette(brewer.pal(8,\"Spectral\"))(nnodes)\nvalues=rev(colorRampPalette(brewer.pal(8,\"PuBuGn\"))(nnodes))\nvalues=colorRampPalette(brewer.pal(9,\"Spectral\"))(nnodes+10)[14:(nnodes+13)]\nvalues = colorRampPalette(as.character(c(\"#00FF00\",\"#FF0000\",\"#0000FF\")))(nnodes)\nvalues = colorRampPalette(c(rev(brewer.pal(9, \"Blues\")),brewer.pal(9, \"Reds\")))(nnodes)\nvalues = colorRampPalette(as.character(c(\"#f24a57\",\"#7cdac6\",\"#5ba8f6\")))(nnodes)\nvalues = colorRampPalette(as.character(c(\"#e20a17\",\"#64cf97\",\"#0070b8\")))(nnodes)\n\n\n#install.packages(\"nnet\")\nlibrary('nnet')\nfit <- multinom(Allocated ~ x + y + z, data = df)\n\nsummary(fit)\nstr(fit)\nplot(fit, df)\nprint(fit)\nfit$coefs\nfit$terms\nfit$fitted\n\n\n",
    "created" : 1437146679717.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "72730314",
    "id" : "A43C2654",
    "lastKnownWriteTime" : 1437143905,
    "path" : "~/R/ElectoralSpace/ElectoralSpace.R",
    "project_path" : "ElectoralSpace.R",
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "type" : "r_source"
}