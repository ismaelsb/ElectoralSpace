{
    "contents" : "---\ntitle: \"Electoral Space\"\nruntime: shiny\noutput: \n  html_document: \n    fig_height: 9\n    fig_width: 9\n    keep_md: yes\n    toc: yes\n---\n\nCode available here: <http://rpubs.com/ismaelsb/ElectoralSpace>\n \n\n```{r, echo = F, results='hide', message=FALSE, warning=FALSE}\n#Uncommmet to install ggtern from an online CRAN repository:\n#install.packages(\"ggtern\")\n#Load the ggtern library:\nlibrary(ggtern)\n#library(stats)\nset.seed(156) #fix random generation\n\n```\n\n```{r, echo = F}\n\ngenerateNodes <- function(seats){ \n  \n  #define nodes\n  nnodes = (seats+1)*(seats+2)/2;\n  nodes  = matrix(0,nnodes,3);\n  t=1;\n  for (i in 0:seats){\n    for (j in i:seats){\n      nodes[t,] = c(i,j-i,seats-j);\n      t=t+1;\n    }\n  }  \n  \n  index=as.matrix(1:nnodes)\n  \n  #node labels for seats\n  label=cbind(as.character(nodes[,1]),matrix(\"-\",nnodes),as.character(nodes[,2]),matrix(\"-\",nnodes),as.character(nodes[,3]))\n  label=do.call(\"paste0\",as.data.frame(label))\n  \n  \n  nodes <- cbind(index,as.data.frame(nodes),label)\n  names(nodes) <- c(\"index\",letters[24:26],\"label\")\n  return(nodes);\n  \n}\n\n```\n\n```{r, echo = F}\n\ngenerateColors <- function (colorRGB, seats) {\n  \n  nnodes = (seats+1)*(seats+2)/2;\n  nodes <- as.matrix(generateNodes(seats)[,c(\"x\",\"y\",\"z\")])\n  #decimal codes for colors in nodes\n  Code3 = floor(nodes*255.9/seats) #255.9 avoids seats -> 256 -> HEX #100 case\n  #linear transformation to fixed extreme colors\n  CodeDecRGB = floor(Code3%*%matrix(colorRGB,3,3, byrow=T)/256)\n  #hex codes for colors in nodes\n  CodeRGB=cbind(matrix(\"#\",nnodes),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))\n  CodeRGB=do.call(\"paste0\",as.data.frame(CodeRGB))\n  values=CodeRGB\n  \n  return(values);\n  \n}\n\n```\n\n```{r, echo = F}\n\nalloc <- function(parties, votes, seats, step, threshold=0){\n  \n  #function for the seat allocation and its ordering\n  #computes allocation for several values of seats and divisor step methods\n  #with the same quotiens table\n  votes=votes*(votes>=(threshold*sum(votes)))\n  Mst <- max(step)\n  Mse <- max(seats)\n  nquotients=(1+Mst*(Mse-1))\n  \n  #table with all the quotients needed\n  quotienstable <- data.frame( \n    parties    = rep(parties, each = nquotients), \n    quotients  = as.vector(sapply(votes, function(x) \n      x/seq(from=1, to=nquotients) )),\n    votesrep   = rep(votes, each = nquotients)\n  ) \n  \n  SeatsList=list()\n  filteredtable =list()\n  \n  \n  for (j in 1:length(step)) {\n    \n    \n    #select from the table of all quotiens the ones whose divisors\n    #belong to the current sequence, given 'seats' and 'step'\n    select <- rep(seq(from=1, to=1+step[j]*(Mse-1), by=step[j]),length(parties))+\n      rep(seq(from=0,to=nquotients*length(parties)-1,by=nquotients),each=Mse)\n    \n    filteredtable [[j]] <- quotienstable$parties[select][order(-quotienstable$quotients[select], -quotienstable$votesrep[select])]\n    \n    SeatsList[[j]]<-list()\n    \n    #a vector of values for seats if you want to compute the partial sums\n    for (i in 1:length(seats)){\n      SeatsList[[j]][[i]]= table(filteredtable[[j]][1:seats[i]])\n    }\n    \n    names(SeatsList[[j]])[1:length(seats)]<-do.call(\"paste0\",as.data.frame(cbind(\"divisor step \",step[j],\" for \", seats,\" seats\")))\n    \n    \n    SeatsList[[j]][[length(seats)+1]] = as.matrix(filteredtable[[j]][1:Mse]) #ordering\n    \n    names(SeatsList[[j]])[length(seats)+1]<-paste0(\"ordering for divisor step \", step[j],\" for \", Mse,\" seats\")\n    \n    \n  }\n  \n  \n  return(SeatsList);\n  \n}\n\n```\n\n```{r, echo = F}\n\ngenerateDots <- function(dotsperside, method=\"lattice\"){\n  \n  dots <- (dotsperside+1)*(dotsperside+2)/2\n  \n  if (method == \"cartesian\") {\n    #Map Cartesian to Ternary to produce a homegeneous simulation\n    Rc = matrix(runif(2*dots), nrow=dots, ncol=2)\n    R  = matrix(apply(Rc,1, CartesianToTernary), nrow=dots, ncol=3, byrow=TRUE)\n  }\n  \n  else if (method == \"ternary\") {\n    #Ternary simulation. Projects points in[0,1]^3 to the sum(x)=1 hyperplane\n    #This creates way more points in the center than in the extremes\n    R = matrix(runif(3*dots), nrow=dots, ncol=3)\n    R = prop.table(R,1) #rows sum 1\n  }\n  \n  else if (method == \"lattice\") {\n    #lattice of dots\n    \n    #read this if you want to use dots instead of dotsperside as input variable:\n    #if n is dotsperside\n    #dots <- (n+1)*(n+2)/2  \n    #inverse calculation:\n    #n <- floor((sqrt(8*dots+1)-3)/2) #exact\n    #n <- floor(sqrt(2*dots)) #aprox\n    \n    #then redefine number of dots\n    #dots <- (n+1)*(n+2)/2\n    R <- matrix(0,nrow=dots, ncol=3)\n    i <- 1\n    for (x in 0:dotsperside){\n      \n      for (y in 0:(dotsperside-x)){\n        \n        R[i,]<- c(x,y,dotsperside-x-y)\n        i <- i+1\n        \n      }\n    }\n    R = prop.table(R,1) #rows sum 1\n  }\n  \n  return(R);\n  \n}\n\n```\n\n```{r, echo = F}\n\nCartesianToTernary <- function (x) {\n  \n  #for homogeneous simulation\n  #send an subset of [0,1]x[0,1] which is an equilateral triangle to the ternary diagram \n  \n  while ((x[1]<=1/2 & x[2]>2*sin(pi/3)*x[1]) | (x[1]>1/2 & x[2]>2*sin(pi/3)*(1-x[1])))\n    x=runif(2);\n  \n  v = cbind(1-x[1]-x[2]/(2*sin(pi/3)),x[2]/sin(pi/3),x[1]-x[2]/(2*sin(pi/3)));\n  \n  return(v);\n  \n}\n\n```\n\n```{r, echo = F}\n\nUniformNearest <- function (x, seats, nodes, nnodes) {\n  \n  Uniform = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,max))\n  \n  return(Uniform);\n  \n}\n\n```\n\n```{r, echo = F}\n\nManhattanNearest <- function (x, seats, nodes, nnodes) {\n  \n  Manhattan = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,sum))\n  \n  return(Manhattan);\n  \n}\n\n```\n\n```{r, echo = F}\n\nEuclidNearest <- function (x, seats, nodes, nnodes) {\n  \n  Euclid = which.min(apply((nodes/seats - rep(1,nnodes) %*% t(x))^2,1,sum))\n  \n  return(Euclid);\n  \n}\n\n```\n\n```{r, echo = F}\n\nAllocatedNode <- function (y, nodes, nnodes) {\n  \n  Node = which.min(apply(abs(nodes - rep(1,nnodes) %*% t(y)),1,max))\n  \n  return(Node);\n  \n}\n\n```\n\n```{r, echo = F}\n\nSpatialData <- function (dotsperside, seats, step=1, threshold=0, method=\"lattice\") {\n  \n  \n  #Generate random electoral results\n  R <- generateDots(dotsperside, method=method)\n  dots=dim(R)[1]  #dots <- (dotsperside+1)*(dotsperside+2)/2\n  \n  Seats=max(seats)\n  \n  #nodes\n  nodes  <- as.matrix(generateNodes(Seats)[,c(\"x\",\"y\",\"z\")])\n  nnodes <- (Seats+1)*(Seats+2)/2;\n  \n  #Indexes for Voronoi regions\n  Uniform   = apply(R, 1, UniformNearest,   seats=Seats, nodes = nodes, nnodes=nnodes)\n  Manhattan = apply(R, 1, ManhattanNearest, seats=Seats, nodes = nodes, nnodes=nnodes)\n  Euclid    = apply(R, 1, EuclidNearest,    seats=Seats, nodes = nodes, nnodes=nnodes)\n  \n  #allocate seats\n  AllocStructure <- apply(R, 1, function(x) alloc(as.character(1:3), x, seats, step, threshold))\n  #input a vector of values for seats of to compute partial sums\n  \n  df=list() #list of dataframes, one for each 'step' value\n  \n  #loop for diferent 'step's\n  for (j in 1:length(step)){\n    \n    #allocation\n    AllocPartial=matrix(0,dots,length(seats))\n    \n    for (i in 1:length(seats)){\n      \n      S = t(matrix(sapply(AllocStructure, function(x) x[[j]][[i]]),nrow=3,ncol=dots))\n      \n      nodes_sub <- as.matrix(generateNodes(seats[i])[,c(\"x\",\"y\",\"z\")])\n      \n      AllocPartial[,i] = apply(S, 1, AllocatedNode, nodes=nodes_sub, nnodes=(seats[i]+1)*(seats[i]+2)/2)\n      \n    }\n    \n    #allocation order\n    #computes allocation ordering for max(seats) in each step value\n    AllocOrder = t(matrix(sapply(AllocStructure, function(x) as.integer(x[[j]][[length(seats)+1]])),nrow=Seats,ncol=dots))\n    vectorOrderCode=as.matrix(3^(0:(Seats-1)))\n    #this coding highlights the last seats over the first ones\n    # so that there is contrast between adjacent regions\n    AllocOrderCode = (matrix(AllocOrder, ncol=Seats)-1) %*% as.matrix(vectorOrderCode)\n    \n    dfPartial=as.data.frame(AllocPartial)\n    names(dfPartial) <- do.call(paste0,as.data.frame(cbind(\"All\",seats)))\n    names(dfPartial)[which(seats==Seats)] <- \"Allocated\"\n    \n    #assembling a data frame\n    df0 = data.frame(\n      \n      \n      x             = as.matrix(R[,1]),\n      y             = as.matrix(R[,2]),\n      z             = as.matrix(R[,3]),\n      \n      Sx            = S[,1],\n      Sy            = S[,2],\n      Sz            = S[,3],\n      \n      Euclid,\n      Manhattan,\n      Uniform,\n      \n      Malapportionment = AllocPartial[1:dots,length(seats)] != Euclid[1:dots],\n      \n      AllocOrderCode\n      \n      \n    )\n    \n    df0=cbind(df0,dfPartial)\n    \n    df[[j]]<-df0\n    \n  } #end of loop for different 'step's\n  \n  \n  return(df);\n  \n}\n\n```\n\n```{r, echo = F}\n\ngenerateOrderColors <- function (colorRGB, seats, validCodes=TRUE) {\n  \n  #generate order color from alloc order codes\n  \n  #extract allocation order from allocation order codes:\n  OrderCode <-as.matrix(0:(3^seats-1))\n  \n  OrderRests <- t(matrix(apply(OrderCode, 1, function(x) x %% (3^(1:seats))),ncol=3^seats, nrow=seats))\n  #(this is vectorial for OrderRests <- OrderCode %% (3^(1:seats))  )\n  \n  Order_from_code <- (cbind(OrderRests,0)-cbind(0,OrderRests))[,1:seats]/t(matrix(rep(3^(0:(seats-1)),3^seats),ncol=3^seats,nrow=seats))+1\n  vectorOrderCode3 <- 2^(0:(seats-1))\n  #decimal codes for colors in nodes\n  Code3 = cbind((Order_from_code == 1)%*%as.matrix(vectorOrderCode3),\n                (Order_from_code == 2)%*%as.matrix(vectorOrderCode3),\n                (Order_from_code == 3)%*%as.matrix(vectorOrderCode3))\n  \n  #linear transformation to fixed extreme colors\n  CodeDecRGB = floor(Code3%*%matrix(colorRGB,3,3, byrow=T)/2^seats)\n  \n  #hex codes for colors in nodes\n  CodeRGB = cbind(matrix(\"#\",3^seats),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))\n  CodeRGB = do.call(\"paste0\",as.data.frame(CodeRGB))\n  \n  #values = CodeRGB[validCodes]\n  values = CodeRGB[c(validCodes, 3^seats)] #added one more color bc scale_color_manual() demanded one more color\n  #values = CodeRGB[c(1, validCodes)] #added one more color bc scale_color_manual() demanded one more color\n  \n  \n  return(values);\n  \n}\n\n```\n\n```{r, echo = F}\n\n#history of election results\n\nVotesData <- function (votes=matrix(0,1), election=matrix(0,1)) {\n  \n  votes <- prop.table(votes,1)  \n  \n  x <- votes[,1]\n  y <- votes[,2]\n  z <- votes[,3]\n  \n  el=dim(votes)[1]\n  label = as.character(election)\n  \n  \n  #assembling a data frame\n  df = data.frame(\n    \n    type = matrix(\"vote\",el,1),\n    \n    x ,\n    y ,\n    z ,\n    \n    label,\n    \n    election,\n    \n    color = matrix(NA,el,1)\n    \n  )\n  \n  return(df);\n  \n}\n\n```\n\n```{r, echo = F}\n\ngenerateSpline <- function (dfvotes, method = \"natural\") {\n  \n  #generates a spline curve through elections history\n  \n  nelect = dim(dfvotes)[1]\n  \n  splineX <- spline(x=1:nelect,y=dfvotes$x, method=method)\n  splineY <- spline(x=1:nelect,y=dfvotes$y, method=method)\n  \n  dfSpline = matrix(0, length(splineX[[1]]), 3)\n  dfSpline[,1] <- splineX[[2]]\n  dfSpline[,2] <- splineY[[2]]\n  dfSpline[,3] <- 1-dfSpline[,1]-dfSpline[,2]\n  dfSpline = as.data.frame(dfSpline)\n  names(dfSpline) <- letters[24:26]\n  \n  return(dfSpline);\n  \n}\n\n```\n\n```{r, echo=FALSE}\ninputPanel(\n  \n  #radioButtons(\"step\", label = \"Number of steps:\", 1:3, selected=1, inline=T),\n  \n  radioButtons(\"electmethod\", label = \"Electoral method:\", c(\"D'Hondt\",\"Sainte-Lague\", \"Danish\"), selected=\"D'Hondt\", inline=F),\n  \n  sliderInput(\"seats\", label = \"Number of seats:\",\n              min = 1, max = 25, value = 5, step = 1),\n  \n  sliderInput(\"threshold\", label = \"Threshold:\",\n              min = 0, max = .30, value = 0, step = .01)\n)\n\ninputPanel(\n  \n  checkboxGroupInput(\"ChoosePlots\", \"More plots:\",\n                   c(\"Allocation\" = \"Qp\",\n                     \"Malapportionment\" = \"Mp\",\n                     \"Voronoi\" = \"Vp\",\n                     \"Ordering\" = \"Op\"), selected = \"Qp\"),\n  \n  selectInput(\"method\", label = \"Dot distribution:\",\n              choices = c(\"lattice\",\"cartesian\",\"ternary\"), selected = \"lattice\"),\n  \n  sliderInput(\"dotsperside\", label = \"Dot density:\",\n              min = 50, max = 300, value = 120, step = 10)\n\n)\n  \ninputPanel(\n  \n  selectInput(\"color1\", label = \"Color 1:\",\n              choices = c('antiquewhite','aquamarine3','azure1','brown3','brown4','burlywood4','cadetblue','coral3','cornsilk','cornsilk2','cyan3','darkcyan','darkolivegreen4','darkorange2','darkred','darkslategray','darkseagreen','darksalmon','darkslategray3','deeppink4','dodgerblue3','darkorchid2','dodgerblue4','firebrick3','floralwhite','honeydew3','hotpink4','khaki3','khaki4','lavenderblush3','lightblue3','lightcyan2','lightpink2','lightsalmon2','lightsteelblue3','lightyellow1','indianred3','indianred4','ivory','ivory3','midnightblue','mintcream','mistyrose2','navajowhite1','orangered4','paleturquoise2','palegreen3','rosybrown2','royalblue3','salmon','seagreen','seashell1','sienna2','turquoise3','wheat2','black','gray10','gray30','gray50','gray70','gray90','white'), selected = 'indianred3'),\n  \n  selectInput(\"color2\", label = \"Color 2:\",\n              choices = c('antiquewhite','aquamarine3','azure1','brown3','brown4','burlywood4','cadetblue','coral3','cornsilk','cornsilk2','cyan3','darkcyan','darkolivegreen4','darkorange2','darkred','darkslategray','darkseagreen','darksalmon','darkslategray3','deeppink4','dodgerblue3','darkorchid2','dodgerblue4','firebrick3','floralwhite','honeydew3','hotpink4','khaki3','khaki4','lavenderblush3','lightblue3','lightcyan2','lightpink2','lightsalmon2','lightsteelblue3','lightyellow1','indianred3','indianred4','ivory','ivory3','midnightblue','mintcream','mistyrose2','navajowhite1','orangered4','paleturquoise2','palegreen3','rosybrown2','royalblue3','salmon','seagreen','seashell1','sienna2','turquoise3','wheat2','black','gray10','gray30','gray50','gray70','gray90','white'), selected = 'aquamarine3'),\n  \n  selectInput(\"color3\", label = \"Color 3:\",\n              choices = c('antiquewhite','aquamarine3','azure1','brown3','brown4','burlywood4','cadetblue','coral3','cornsilk','cornsilk2','cyan3','darkcyan','darkolivegreen4','darkorange2','darkred','darkslategray','darkseagreen','darksalmon','darkslategray3','deeppink4','dodgerblue3','darkorchid2','dodgerblue4','firebrick3','floralwhite','honeydew3','hotpink4','khaki3','khaki4','lavenderblush3','lightblue3','lightcyan2','lightpink2','lightsalmon2','lightsteelblue3','lightyellow1','indianred3','indianred4','ivory','ivory3','midnightblue','mintcream','mistyrose2','navajowhite1','orangered4','paleturquoise2','palegreen3','rosybrown2','royalblue3','salmon','seagreen','seashell1','sienna2','turquoise3','wheat2','black','gray10','gray30','gray50','gray70','gray90','white'), selected = 'royalblue3')\n  \n)\n\nrenderPlot({\n\n  dots <- (input$dotsperside+1)*(input$dotsperside+2)/2\n  \n  colorRGB0 <- matrix(rbind(col2rgb(input$color1),\n                            col2rgb(input$color2),\n                            col2rgb(input$color3)),1,9)\n  \n  #step <- as.integer(input$step)\n  \n  if (input$electmethod == \"D'Hondt\"){\n    \n    step <- 1\n    \n  } else if (input$electmethod == \"Sainte-Lague\"){\n    \n    step <- 2\n    \n  } else if (input$electmethod == \"Danish\"){\n    \n    step <- 3\n    \n  }\n  \n  NodesData <- generateNodes(input$seats)\n  \n  df = SpatialData(dotsperside=input$dotsperside-1, seats=input$seats, step=step, threshold=input$threshold, method=input$method) \n    \n  Qp <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Allocated)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Quotients Allocation\")+\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\n  scale_colour_manual(values=generateColors(colorRGB0,input$seats),guide=FALSE,na.value=\"khaki2\")\n  \n  Mp <- ggtern(data=df[[1]],aes(x,y,z,color=Malapportionment)) +\n  theme_rgbw() +\n  geom_point(alpha=0.8) +\n  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color=\"grey60\")+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Malapportionment\")+\n  #scale_colour_grey(na.value = \"black\", guide = FALSE)\n  scale_colour_brewer(palette = \"YlGnBu\", na.value = \"grey60\", guide = FALSE)\n  \n  Vp <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Manhattan)))+\n  theme_bw()+\n  geom_point(alpha=1)+\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Voronoi Allocation\")+\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\n  scale_colour_manual(values=generateColors(colorRGB0,input$seats), guide=FALSE, na.value=\"khaki2\")\n  \n  Op <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(AllocOrderCode))) +\n  theme_bw()+\n  geom_point(alpha=1) +\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Allocation Ordering\")+\n  scale_colour_manual(values=\n      generateOrderColors(colorRGB0,input$seats,sort(unique(df[[1]]$AllocOrderCode))),guide=FALSE, na.value=\"khaki2\")\n  \n  \n  plist=list(Qp,Mp,Vp,Op)\n  names(plist) <- c(\"Qp\",\"Mp\",\"Vp\",\"Op\")\n  ggtern.multi(plotlist=plist[input$ChoosePlots], cols=length(input$ChoosePlots))\n\n    \n  \n})\n\n#renderPlot({\n\n\n#size of the regions # 1 ~= dots/nnodes\n#nnodes=(input$seats+1)*(input$seats+2)/2;\n#RegionSizeQ  = table(df[[1]]$Allocated[1:dots])/(dots/nnodes)\n#RegionSizeV  = table(df[[1]]$Manhattan[1:dots])/(dots/nnodes)\n\n  \n#par(mfrow=c(3,1))\n#plot(RegionSizeQ, main=\"Quotients region sizes\")\n#plot(RegionSizeV, main=\"Voronoi region sizes\" )\n#par(mfrow=c(1,1))\n\n\n#points not allocated by the quotients method in their corresponding Voronoi region\n#sum(df[[1]]$Malapportionment[1:dots])/dots\n  \n\n  \n#})\n\n```\n\n\n",
    "created" : 1437146394639.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1361674088",
    "id" : "C10D8DF",
    "lastKnownWriteTime" : 1437143905,
    "path" : "~/R/ElectoralSpace/ElectoralSpace_shiny.Rmd",
    "project_path" : "ElectoralSpace_shiny.Rmd",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_markdown"
}