---
title: "3Dplots"
output: 
  html_document: 
    fig_width: 9
    keep_md: yes
    toc: yes
---

```{r, echo = F, results='hide', message=FALSE, warning=FALSE}

#Uncommmet to install ggtern from an online CRAN repository:
#install.packages("ggtern")
#install.packages("rgl")
#Load the ggtern library:
library(ggtern)
#library(stats)
library("rgl")
set.seed(156) #fix random generation

```

```{r, echo = F}

alloc <- function(parties, votes, seats, step, threshold=0){
  
  #function for the seat allocation and its ordering
  #computes allocation for several values of seats and divisor step methods
  #with the same quotiens table
  votes=votes*(votes>=(threshold*sum(votes)))
  Mst <- max(step)
  Mse <- max(seats)
  nquotients=(1+Mst*(Mse-1))
  
  #table with all the quotients needed
  quotienstable <- data.frame( 
    parties    = rep(parties, each = nquotients), 
    quotients  = as.vector(sapply(votes, function(x) 
      x/seq(from=1, to=nquotients) )),
    votesrep   = rep(votes, each = nquotients)
  ) 
  
  SeatsList=list()
  filteredtable =list()
  
  
  for (j in 1:length(step)) {
    
    
    #select from the table of all quotiens the ones whose divisors
    #belong to the current sequence, given 'seats' and 'step'
    select <- rep(seq(from=1, to=1+step[j]*(Mse-1), by=step[j]),length(parties))+
      rep(seq(from=0,to=nquotients*length(parties)-1,by=nquotients),each=Mse)
    
    filteredtable [[j]] <- quotienstable$parties[select][order(-quotienstable$quotients[select], -quotienstable$votesrep[select])]
    
    SeatsList[[j]]<-list()
    
    #a vector of values for seats if you want to compute the partial sums
    for (i in 1:length(seats)){
      SeatsList[[j]][[i]]= table(filteredtable[[j]][1:seats[i]])
    }
    
    names(SeatsList[[j]])[1:length(seats)]<-do.call("paste0",as.data.frame(cbind("divisor step ",step[j]," for ", seats," seats")))
    
    
    SeatsList[[j]][[length(seats)+1]] = as.matrix(filteredtable[[j]][1:Mse]) #ordering
    
    names(SeatsList[[j]])[length(seats)+1]<-paste0("ordering for divisor step ", step[j]," for ", Mse," seats")
    
    
  }
  
  
  return(SeatsList);
  
}

```

```{r, echo = F}

normalizenodes <- function (nodes) {
  
  normnodes <- nodes
  for (i in 1:dim(nodes)[1]){
    normnodes[i,] <- nodes[i,]/norm(as.matrix(nodes[i,]),"F")
  }
  
  normnodes <- as.matrix(normnodes)
  
}

```

```{r, echo = F}

UniformNearest <- function (x, seats, nodes, nnodes) {
  
  Uniform = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,max))
  
  return(Uniform);
  
}

```

```{r, echo = F}

ManhattanNearest <- function (x, seats, nodes, nnodes) {
  
  Manhattan = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,sum))
  
  return(Manhattan);
  
}

```

```{r, echo = F}

EuclidNearest <- function (x, seats, nodes, nnodes) {
  
  Euclid = which.min(apply((nodes/seats - rep(1,nnodes) %*% t(x))^2,1,sum))
  
  return(Euclid);
  
}

```

```{r, echo = F}

OrthodromicNearest <- function (x, seats, nodes, nnodes) {
  
  normnodes <- normalizenodes(nodes)
  Orthodromic = which.min(acos((x/norm(t(x),"F")) %*% t(as.matrix(normnodes))))
  
  return(Orthodromic);
  
}

```

```{r, echo = F}

AllocatedNode <- function (y, nodes, nnodes) {
  
  Node = which.min(apply(abs(nodes - rep(1,nnodes) %*% t(y)),1,max))
  
  return(Node);
  
}

```

```{r, echo = F}

generate4Nodes <- function(seats){ 
  
  #define nodes
  nnodes = (seats+1)*(seats+2)*(seats+3)/6;
  nodes  = matrix(0,nnodes,4);
  t=1;
  for (i in 0:seats){
    for (j in i:seats){
      for (k in j:seats){
        nodes[t,] = c(i,j-i,k-j,seats-k);
        t=t+1;
      }
    }
  }
  
  normnodes = prop.table(nodes,1) #rows sum 1
  NodesCoords <- normnodes %*% SimplexToCartesian
  
  index=as.matrix(1:nnodes)
  
  #node labels for seats
  label=cbind(as.character(nodes[,1]),matrix("-",nnodes),as.character(nodes[,2]),matrix("-",nnodes),as.character(nodes[,3]),matrix("-",nnodes),as.character(nodes[,4]))
  label=do.call("paste0",as.data.frame(label))
  
  
  nodes <- cbind(index, NodesCoords, as.data.frame(nodes),label)
  names(nodes) <- c("index", letters[24:26], letters[1:4],"label")
  return(nodes);
  
}

generateColors4 <- function (colorRGB, seats) {
  
  nnodes = (seats+1)*(seats+2)*(seats+3)/6;
  nodes <- as.matrix(generate4Nodes(seats)[,c("a","b","c","d")])
  #decimal codes for colors in nodes
  Code4 = floor(nodes*255.9/seats) #255.9 avoids seats -> 256 -> HEX #100 case
  #linear transformation to fixed extreme colors
  CodeDecRGB = floor(Code4%*%matrix(colorRGB,4,3, byrow=T)/256)
  #hex codes for colors in nodes
  CodeRGB=cbind(matrix("#",nnodes),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))
  CodeRGB=do.call("paste0",as.data.frame(CodeRGB))
  values=CodeRGB
  
  return(values);
  
}

generateDots <- function(dotsperside, method="lattice"){
  
  dots <- (dotsperside+1)*(dotsperside+2)/2
  
  if (method == "cartesian") {
    #Map Cartesian to Ternary to produce a homegeneous simulation
    Rc = matrix(runif(2*dots), nrow=dots, ncol=2)
    R  = matrix(apply(Rc,1, CartesianToTernary), nrow=dots, ncol=3, byrow=TRUE)
  }
  
  else if (method == "ternary") {
    #Ternary simulation. Projects points in[0,1]^3 to the sum(x)=1 hyperplane
    #This creates way more points in the center than in the extremes
    R = matrix(runif(3*dots), nrow=dots, ncol=3)
    R = prop.table(R,1) #rows sum 1
  }
  
  else if (method == "lattice") {
    #lattice of dots
    
    #read this if you want to use dots instead of dotsperside as input variable:
    #if n is dotsperside
    #dots <- (n+1)*(n+2)/2  
    #inverse calculation:
    #n <- floor((sqrt(8*dots+1)-3)/2) #exact
    #n <- floor(sqrt(2*dots)) #aprox
    
    #then redefine number of dots
    #dots <- (n+1)*(n+2)/2
    R <- matrix(0,nrow=dots, ncol=3)
    i <- 1
    for (x in 0:dotsperside){
      
      for (y in 0:(dotsperside-x)){
        
        R[i,]<- c(x,y,dotsperside-x-y)
        i <- i+1
        
      }
    }
    R = prop.table(R,1) #rows sum 1
  }
  
  else if (method == "tetrahedron") {
    
    dots <- (dotsperside+1)*(dotsperside+2)*(dotsperside+3)/6
    
    R <- matrix(0,nrow=dots, ncol=4)
    i <- 1
    for (w in 0:dotsperside){
      
      for (x in 0:(dotsperside-w)){
        
        for (y in 0:(dotsperside-w-x)){
          
          R[i,]<- c(w,x,y,dotsperside-w-x-y)
          i <- i+1
          
          
        }
      }
    }
    R = prop.table(R,1) #rows sum 1
    
    
  }
  
  return(R);
  
}

SpatialData4 <- function (dotsperside, seats, step=1, threshold=0, method="tetrahedron") {
  
  
  #Generate random electoral results
  R <- generateDots(dotsperside, method=method)
  dots=dim(R)[1]  #dots <- (dotsperside+1)*(dotsperside+2)*(dotsperside+3)/6
  
  Coords <- R %*% SimplexToCartesian
  
  
  Seats=max(seats)
  
  #nodes
  nodes  <- as.matrix(generate4Nodes(Seats)[,c("a","b","c","d")])
  nnodes <- (Seats+1)*(Seats+2)*(Seats+3)/6;
  
  #Indexes for Voronoi regions
  Uniform   = apply(R, 1, UniformNearest,   seats=Seats, nodes = nodes, nnodes=nnodes)
  Manhattan = apply(R, 1, ManhattanNearest, seats=Seats, nodes = nodes, nnodes=nnodes)
  Euclid    = apply(R, 1, EuclidNearest,    seats=Seats, nodes = nodes, nnodes=nnodes)
  Orthodromic=apply(R, 1, OrthodromicNearest,seats=Seats,nodes = nodes, nnodes=nnodes)
  
  
  #allocate seats
  AllocStructure <- apply(R, 1, function(x) alloc(as.character(1:4), x, seats, step, threshold))
  #input a vector of values for seats of to compute partial sums
  
  df=list() #list of dataframes, one for each 'step' value
  
  #loop for diferent 'step's
  for (j in 1:length(step)){
    
    #allocation
    AllocPartial=matrix(0,dots,length(seats))
    
    for (i in 1:length(seats)){
      
      S = t(matrix(sapply(AllocStructure, function(x) x[[j]][[i]]),nrow=4,ncol=dots))
      
      nodes_sub <- as.matrix(generate4Nodes(seats[i])[,c("a","b","c","d")])
      
      AllocPartial[,i] = apply(S, 1, AllocatedNode, nodes=nodes_sub, nnodes=(seats[i]+1)*(seats[i]+2)*(seats[i]+3)/6)
      
    }
    
    #allocation order
    #computes allocation ordering for max(seats) in each step value
    AllocOrder = t(matrix(sapply(AllocStructure, function(x) as.integer(x[[j]][[length(seats)+1]])),nrow=Seats,ncol=dots))
    vectorOrderCode=as.matrix(4^(0:(Seats-1)))
    #this coding highlights the last seats over the first ones
    # so that there is contrast between adjacent regions
    AllocOrderCode = (matrix(AllocOrder, ncol=Seats)-1) %*% as.matrix(vectorOrderCode)
    
    dfPartial=as.data.frame(AllocPartial)
    names(dfPartial) <- do.call(paste0,as.data.frame(cbind("All",seats)))
    names(dfPartial)[which(seats==Seats)] <- "Allocated"
    
    #assembling a data frame
    df0 = data.frame(
      
      x             = as.matrix(Coords[,1]),
      y             = as.matrix(Coords[,2]),
      z             = as.matrix(Coords[,3]),
      
      x1             = as.matrix(R[,1]),
      x2             = as.matrix(R[,2]),
      x3             = as.matrix(R[,3]),
      x4             = as.matrix(R[,4]),
      
      S1            = S[,1],
      S2            = S[,2],
      S3            = S[,3],
      S4            = S[,3],
      
      Euclid,
      Manhattan,
      Uniform,
      Orthodromic,
      
      Malapportionment = AllocPartial[1:dots,length(seats)] != Euclid[1:dots],
      Malapportionment2 = AllocPartial[1:dots,length(seats)] != Orthodromic[1:dots],
      
      AllocOrderCode
      
      
    )
    
    df0=cbind(df0,dfPartial)
    
    df[[j]]<-df0
    
  } #end of loop for different 'step's
  
  
  return(df);
  
}

generate4Colors <- function (color4RGB, seats, df) {
  
  Seats <- max(seats)
  ColorMatrix = matrix(color4RGB, 4,3, byrow=T)
  NodesData <- generate4Nodes(Seats)
  
  dColors <- as.data.frame(as.matrix(NodesData[df$Allocated,][,5:8]/Seats)%*%ColorMatrix/256)
  names(dColors) <- c("R","G","B")
  
  return(dColors);
  
}

#Voronoi
generate4VColors <- function (color4RGB, seats, df) {
  
  Seats <- max(seats)
  ColorMatrix = matrix(color4RGB, 4,3, byrow=T)
  NodesData <- generate4Nodes(Seats)
  
  dColors <- as.data.frame(as.matrix(NodesData[df$Uniform,][,5:8]/Seats)%*%ColorMatrix/256)
  names(dColors) <- c("R","G","B")
  
  return(dColors);
  
}

generate4alpha <- function (df) {
  
  alpha=0.05+.6*(df$CameraEntropy/max(df$CameraEntropy))^3
  
  return(alpha);
  
}

generate4Valpha <- function (seats, df) {
  
  VCameraEntropy <- rowSums(-NodesData[df$Uniform,5:8]/max(seats)*modifiedlog(NodesData[df$Uniform,5:8]/max(seats)))
  alpha=0.05+.6*(VCameraEntropy/max(VCameraEntropy))^3
  
  return(alpha);
  
}


modifiedlog <- function(x) {
  
  #modified log function for the calculation of entropy
  #avoids log(0)=NaN
  
  x <- as.matrix(x)
  r<-log(x)
  r[is.finite(r)==F] <-0
  return(r)
  
}


```

```{r, echo = F, warning=FALSE}

#Transform data from 4-simplex to 3D space
SimplexCoordinates <- c(0, 0, 0,   1, 0, 0,   1/2, sqrt(3)/2, 0,   1/2, sqrt(3)/6, sqrt(2/3))
#SimplexCoordinates <- c(1, 1, 1,   1, -1, -1,  -1, 1, -1,  -1, -1, 1)
SimplexToCartesian <- matrix(SimplexCoordinates,nrow=4,ncol=3,byrow=T)


seats=5
NodesData <- generate4Nodes(max(seats))

#colors for palettes
color4RGB <- c(242,74,87, 122,55,139,  2,114,195, 255,127,0) #<--RPBO
color4RGB <- c(242,74,87, 124,218,198, 2,114,195, 130,20,070) #<--RGBP
color4RGB <- c(242,74,87, 124,218,198, 2,114,195, 210,230,10) #<--RGBY

#plot nodes for seat allocation
ggplot(data=NodesData,aes(x,y,z,color=as.factor(index)))+
  theme_minimal()+
  geom_point(alpha=1, size=5)+
  geom_text(aes(label=label,color=as.factor(index)), hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Nodes for seat allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors4(color4RGB,max(seats)), guide=FALSE, na.value="khaki2")

```

```{r, echo = F}

#presets
seats=2:5;
step=c(1,2); #(2 Sainte-Laguë 1 D'Hondt)
dotsperside=39 #dots <- (dotsperside+1)*(dotsperside+2)*(dotsperside+3)/6
threshold=0

df4 = SpatialData4(dotsperside, seats, step)


#Entropy
Seats <- length(seats)
df4[[1]][,18+Seats+1] <- rowSums(-df4[[1]][,4:7]*modifiedlog(df4[[1]][,4:7]))
df4[[1]][,18+Seats+2] <- rowSums(-df4[[1]][,8:11]/max(seats)*modifiedlog(df4[[1]][,8:11]/max(seats)))

#Effective number of parties
df4[[1]][,18+Seats+3] <- 1/rowSums((df4[[1]][,4:7])^2)
df4[[1]][,18+Seats+4] <- 1/rowSums((df4[[1]][,8:11]/max(seats))^2)

names(df4[[1]])[(18+Seats+1):(18+Seats+4)] <- c('Entropy','CameraEntropy','Parties','CameraParties')


#Entropy
Seats <- length(seats)
df4[[2]][,18+Seats+1] <- rowSums(-df4[[2]][,4:7]*modifiedlog(df4[[2]][,4:7]))
df4[[2]][,18+Seats+2] <- rowSums(-df4[[2]][,8:11]/max(seats)*modifiedlog(df4[[2]][,8:11]/max(seats)))

#Effective number of parties
df4[[2]][,18+Seats+3] <- 1/rowSums((df4[[2]][,4:7])^2)
df4[[2]][,18+Seats+4] <- 1/rowSums((df4[[2]][,8:11]/max(seats))^2)

names(df4[[2]])[(18+Seats+1):(18+Seats+4)] <- c('Entropy','CameraEntropy','Parties','CameraParties')

```


```{r, echo = F, warning=FALSE}

ggplot(data=df4[[1]],aes(x,y,z,color=as.factor(Allocated)))+
  theme_bw()+
  geom_point(alpha=.5)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="D'Hondt Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors4(color4RGB,max(seats)), guide=FALSE, na.value="khaki2")


#size of the regions # 1 ~= dots/nnodes
nnodes=(max(seats)+1)*(max(seats)+2)*(max(seats)+2)/6
dots <- (dotsperside+1)*(dotsperside+2)*(dotsperside+3)/6
RegionSize  = table(df4[[1]]$Allocated[1:dots])/(dots/nnodes)
RegionSize2 = table(df4[[2]]$Allocated[1:dots])/(dots/nnodes)

par(mfrow=c(2,1))
plot(RegionSize, main="D'Hondt region sizes")
plot(RegionSize2,main="Sainte-Laguë region sizes" )
par(mfrow=c(1,1))

```

```{r, echo = F}

#Plots for D'Hondt, Sainte-Laguë and Voronoi regions
open3d()

plot3d(df4[[1]]$x, df4[[1]]$y, df4[[1]]$z, 
       col=rgb(generate4Colors(color4RGB, seats, df4[[1]])),
       #alpha=generate4alpha(df4[[1]]),
       xlab="", ylab="", zlab="",
       size=3, box=F, axes=F, top=T, aspect=F)
play3d( spin3d(axis=c(2,2,3), rpm=12), duration = 5 )
#movie3d( spin3d(axis=c(2,2,3), rpm=12), duration = 5 )

plot3d(df4[[2]]$x, df4[[2]]$y, df4[[2]]$z, 
       col=rgb(generate4Colors(color4RGB, seats, df4[[2]])),
       #alpha=generate4alpha(df4[[2]]),
       xlab="", ylab="", zlab="",
       size=3, box=F, axes=F, top=T, aspect=F)
play3d( spin3d(axis=c(2,2,3), rpm=12), duration = 5 )
#movie3d( spin3d(axis=c(2,2,3), rpm=12), duration = 5 )

plot3d(df4[[1]]$x, df4[[1]]$y, df4[[1]]$z, 
       col=rgb(generate4VColors(color4RGB, seats, df4[[1]])),
       #alpha=generate4Valpha(seats,df4[[1]]),
       xlab="", ylab="", zlab="",
       size=3, box=F, axes=F, top=T, aspect=F)
play3d( spin3d(axis=c(2,2,3), rpm=12), duration = 5 )
#movie3d( spin3d(axis=c(2,2,3), rpm=12), duration = 5 )



plot3d(df4[[1]]$x, df4[[1]]$y, df4[[1]]$z, 
       col=rgb(1*(df4[[1]]$Allocated==df4[[1]]$Uniform)%*%matrix(1,1,3)),
       alpha=generate4alpha(df4[[1]]),
       xlab="", ylab="", zlab="",
       size=3, box=F, axes=F, top=T, aspect=F)
play3d( spin3d(axis=c(2,2,3), rpm=12), duration = 5 )
#movie3d( spin3d(axis=c(2,2,3), rpm=12), duration = 5 )

```