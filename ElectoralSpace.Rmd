---
title: "Electoral Space"
output:
  html_document:
    fig_width: 9
    keep_md: yes
    toc: yes
  pdf_document:
    toc: yes
---

Código disponible en <https://github.com/ismaelsb/ElectoralSpace>
 


**Introducción**

Un diagrama ternario se utiliza para representar 3 variables en 2 dimensiones de forma única para cada conjunto de valores proporcionales. Se puede entender el diagrama como la proyección de los puntos del cuadrante positivo del espacio en
el hiperplano cuya suma de coordenadas es 1. La imagen de la proyección es un triángulo equilátero. De la misma manera podemos representar dos valores en un segmento o cuatro valores en un tetraedro.

```{r, echo = F, results='hide', message=FALSE, warning=FALSE}
#Uncommmet to install ggtern from an online CRAN repository:
#install.packages("ggtern")
#Load the ggtern library:
library(ggtern)
#library(stats)
set.seed(156) #fix random generation

```

```{r, echo = F}
#plot example
ggtern(data=data.frame(x=0.2,y=0.3,z=0.5),aes(x,y,z))+
  theme_arrowdefault()+geom_point()

```


**Funciones de asignación electoral (más en el código)**

Un diagrama como éste se puede usar para representar el resultado de unas elecciones en las que los votos se reparten entre 3 partidos. Cada punto del triángulo se representa con tres coordenadas que se corresponden con el porcentaje de voto obtenido por cada partido. Tenemos un número de escaños a repartir y cada posible reparto se representa con un punto resaltado (nodo) en el triángulo con su correspondiente resultado. El método electoral asignará a cada resultado electoral uno de los posibles repartos de escaños. Las regiones de puntos a las que le son asignados un mismo reparto serán representadas con un mismo color. Para dos partidos usaríamos un segmento y para cuatro, un tetraedro. El diagrama es útil para visualizar los posibles escaños en juego cuando el resultado está muy ajustado y próximo a la frontera entre dos o más regiones.

Utilizamos una función de asignación electoral para distintos métodos proporcionales de cocientes con la posibilidad de añadir un umbral de entrada. 

Mostramos algunas de las funciones utilizadas para calcular la asignación y generar los diagramas:

```{r, echo = F}

generateNodes <- function(seats){ 
  
  #define nodes
  nnodes = (seats+1)*(seats+2)/2;
  nodes  = matrix(0,nnodes,3);
  t=1;
  for (i in 0:seats){
    for (j in i:seats){
      nodes[t,] = c(i,j-i,seats-j);
      t=t+1;
    }
  }  
  
  index=as.matrix(1:nnodes)
  
  #node labels for seats
  label=cbind(as.character(nodes[,1]),matrix("-",nnodes),as.character(nodes[,2]),matrix("-",nnodes),as.character(nodes[,3]))
  label=do.call("paste0",as.data.frame(label))
  
  
  nodes <- cbind(index,as.data.frame(nodes),label)
  names(nodes) <- c("index",letters[24:26],"label")
  return(nodes);
  
}

```

```{r, echo = T}

generateColors <- function (colorRGB, seats) {
  
  nnodes = (seats+1)*(seats+2)/2;
  nodes <- as.matrix(generateNodes(seats)[,c("x","y","z")])
  #decimal codes for colors in nodes
  Code3 = floor(nodes*255.9/seats) #255.9 avoids seats -> 256 -> HEX #100 case
  #linear transformation to fixed extreme colors
  CodeDecRGB = floor(Code3%*%matrix(colorRGB,3,3, byrow=T)/256)
  #hex codes for colors in nodes
  CodeRGB=cbind(matrix("#",nnodes),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))
  CodeRGB=do.call("paste0",as.data.frame(CodeRGB))
  values=CodeRGB
  
  return(values);
  
}

```

```{r, echo = F}

#colors for palettes
colorRGB1 <- c(242,74,87, 124,218,198, 91,168,246) #c("#f24a57","#7cdac6","#5ba8f6")
colorRGB2 <- c(226,10,23, 100,207,151, 0,112,184) #c("#e20a17","#64cf97","#0070b8")
colorRGB3 <- c(242,74,87, 124,218,198, 2,114,195) #<--
colorRGB4 <- c(256,0,0, 0,256,0, 0,0,256)
colorRGB5 <- c(224,0,0, 96,224,176, 96,128,224)
colorRGB5 <- c(240,0,0, 96,224,176, 96,128,224)
colorRGB6 <- c(256,256,0, 0,256,256, 256,0,256) ##YMC test shifted colours
colorRGB7 <- c(256,256,256, 256,0,0, 0,0,0) #WRB

colorRGB0 <- colorRGB3 #choose color palette

```

```{r, echo = F}

seats=5
NodesData <- generateNodes(max(seats))

#plot nodes for seat allocation
ggtern(data=NodesData,aes(x,y,z,color=as.factor(index)))+
  theme_minimal()+
  geom_point(alpha=1, size=5)+
  geom_text(aes(label=label,color=as.factor(index)), hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Nodes for seat allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")


```

```{r, echo = T}

alloc <- function(parties, votes, seats, step, threshold=0){
  
  #function for the seat allocation and its ordering
  #computes allocation for several values of seats and divisor step methods
  #with the same quotiens table
  votes=votes*(votes>=(threshold*sum(votes)))
  Mst <- max(step)
  Mse <- max(seats)
  nquotients=(1+Mst*(Mse-1))
  
  #table with all the quotients needed
  quotienstable <- data.frame( 
    parties    = rep(parties, each = nquotients), 
    quotients  = as.vector(sapply(votes, function(x) 
      x/seq(from=1, to=nquotients) )),
    votesrep   = rep(votes, each = nquotients)
  ) 
  
  SeatsList=list()
  filteredtable =list()
  
  
  for (j in 1:length(step)) {
    
    
    #select from the table of all quotiens the ones whose divisors
    #belong to the current sequence, given 'seats' and 'step'
    select <- rep(seq(from=1, to=1+step[j]*(Mse-1), by=step[j]),length(parties))+
      rep(seq(from=0,to=nquotients*length(parties)-1,by=nquotients),each=Mse)
    
    filteredtable [[j]] <- quotienstable$parties[select][order(-quotienstable$quotients[select], -quotienstable$votesrep[select])]
    
    SeatsList[[j]]<-list()
    
    #a vector of values for seats if you want to compute the partial sums
    for (i in 1:length(seats)){
      SeatsList[[j]][[i]]= table(filteredtable[[j]][1:seats[i]])
    }
    
    names(SeatsList[[j]])[1:length(seats)]<-do.call("paste0",as.data.frame(cbind("divisor step ",step[j]," for ", seats," seats")))
    
    
    SeatsList[[j]][[length(seats)+1]] = as.matrix(filteredtable[[j]][1:Mse]) #ordering
    
    names(SeatsList[[j]])[length(seats)+1]<-paste0("ordering for divisor step ", step[j]," for ", Mse," seats")
    
    
  }
  
  
  return(SeatsList);
  
}

```

**Ejemplo de asignación**

```{r, echo = T}

#Allocation example (step=2 Sainte-Laguë; step=1 D'Hondt)
votes <- sample(1:1000, 3) 
votes
#alloc(letters[1:3], votes, seats=5, step=1)
#alloc(letters[1:3], votes, seats=c(3,5,4), step=2:1, threshold=0.5)
alloc(letters[1:3], votes, 9, c(1,2), .05) #print seats sum and allocation

```

```{r, echo = T}

generateDots <- function(dotsperside, method="lattice"){
  
  dots <- (dotsperside+1)*(dotsperside+2)/2
  
  if (method == "cartesian") {
    #Map Cartesian to Ternary to produce a homegeneous simulation
    Rc = matrix(runif(2*dots), nrow=dots, ncol=2)
    R  = matrix(apply(Rc,1, CartesianToTernary), nrow=dots, ncol=3, byrow=TRUE)
  }
  
  else if (method == "ternary") {
    #Ternary simulation. Projects points in[0,1]^3 to the sum(x)=1 hyperplane
    #This creates way more points in the center than in the extremes
    R = matrix(runif(3*dots), nrow=dots, ncol=3)
    R = prop.table(R,1) #rows sum 1
  }
  
  else if (method == "lattice") {
    #lattice of dots
    
    #read this if you want to use dots instead of dotsperside as input variable:
    #if n is dotsperside
    #dots <- (n+1)*(n+2)/2  
    #inverse calculation:
    #n <- floor((sqrt(8*dots+1)-3)/2) #exact
    #n <- floor(sqrt(2*dots)) #aprox
    
    #then redefine number of dots
    #dots <- (n+1)*(n+2)/2
    R <- matrix(0,nrow=dots, ncol=3)
    i <- 1
    for (x in 0:dotsperside){
      
      for (y in 0:(dotsperside-x)){
        
        R[i,]<- c(x,y,dotsperside-x-y)
        i <- i+1
        
      }
    }
    R = prop.table(R,1) #rows sum 1
  }
  
  return(R);
  
}

```

```{r, echo = F}

CartesianToTernary <- function (x) {
  
  #for homogeneous simulation
  #send an subset of [0,1]x[0,1] which is an equilateral triangle to the ternary diagram 
  
  while ((x[1]<=1/2 & x[2]>2*sin(pi/3)*x[1]) | (x[1]>1/2 & x[2]>2*sin(pi/3)*(1-x[1])))
    x=runif(2);
  
  v = cbind(1-x[1]-x[2]/(2*sin(pi/3)),x[2]/sin(pi/3),x[1]-x[2]/(2*sin(pi/3)));
  
  return(v);
  
}

```

```{r, echo = F}

UniformNearest <- function (x, seats, nodes, nnodes) {
  
  Uniform = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,max))
  
  return(Uniform);
  
}

```

```{r, echo = T}

ManhattanNearest <- function (x, seats, nodes, nnodes) {
  
  Manhattan = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,sum))
  
  return(Manhattan);
  
}

```

```{r, echo = F}

EuclidNearest <- function (x, seats, nodes, nnodes) {
  
  Euclid = which.min(apply((nodes/seats - rep(1,nnodes) %*% t(x))^2,1,sum))
  
  return(Euclid);
  
}

```

```{r, echo = F}

AllocatedNode <- function (y, nodes, nnodes) {
  
  Node = which.min(apply(abs(nodes - rep(1,nnodes) %*% t(y)),1,max))
  
  return(Node);
  
}

```

**Matriz de datos (más en el código)**

```{r, echo = T}

SpatialData <- function (dotsperside, seats, step=1, threshold=0, method="lattice") {
  
  
  #Generate random electoral results
  R <- generateDots(dotsperside, method=method)
  dots=dim(R)[1]  #dots <- (dotsperside+1)*(dotsperside+2)/2
  
  Seats=max(seats)
  
  #nodes
  nodes  <- as.matrix(generateNodes(Seats)[,c("x","y","z")])
  nnodes <- (Seats+1)*(Seats+2)/2;
  
  #Indexes for Voronoi regions
  Uniform   = apply(R, 1, UniformNearest,   seats=Seats, nodes = nodes, nnodes=nnodes)
  Manhattan = apply(R, 1, ManhattanNearest, seats=Seats, nodes = nodes, nnodes=nnodes)
  Euclid    = apply(R, 1, EuclidNearest,    seats=Seats, nodes = nodes, nnodes=nnodes)
  
  #allocate seats
  AllocStructure <- apply(R, 1, function(x) alloc(as.character(1:3), x, seats, step, threshold))
  #input a vector of values for seats of to compute partial sums
  
  df=list() #list of dataframes, one for each 'step' value
  
  #loop for diferent 'step's
  for (j in 1:length(step)){
    
    #allocation
    AllocPartial=matrix(0,dots,length(seats))
    
    for (i in 1:length(seats)){
      
      S = t(matrix(sapply(AllocStructure, function(x) x[[j]][[i]]),nrow=3,ncol=dots))
      
      nodes_sub <- as.matrix(generateNodes(seats[i])[,c("x","y","z")])
      
      AllocPartial[,i] = apply(S, 1, AllocatedNode, nodes=nodes_sub, nnodes=(seats[i]+1)*(seats[i]+2)/2)
      
    }
    
    #allocation order
    #computes allocation ordering for max(seats) in each step value
    AllocOrder = t(matrix(sapply(AllocStructure, function(x) as.integer(x[[j]][[length(seats)+1]])),nrow=Seats,ncol=dots))
    vectorOrderCode=as.matrix(3^(0:(Seats-1)))
    #this coding highlights the last seats over the first ones
    # so that there is contrast between adjacent regions
    AllocOrderCode = (matrix(AllocOrder, ncol=Seats)-1) %*% as.matrix(vectorOrderCode)
    
    dfPartial=as.data.frame(AllocPartial)
    names(dfPartial) <- do.call(paste0,as.data.frame(cbind("All",seats)))
    names(dfPartial)[which(seats==Seats)] <- "Allocated"
    
    #assembling a data frame
    df0 = data.frame(
      
      
      x             = as.matrix(R[,1]),
      y             = as.matrix(R[,2]),
      z             = as.matrix(R[,3]),
      
      Sx            = S[,1],
      Sy            = S[,2],
      Sz            = S[,3],
      
      Euclid,
      Manhattan,
      Uniform,
      
      Malapportionment = AllocPartial[1:dots,length(seats)] != Euclid[1:dots],
      
      AllocOrderCode
      
      
    )
    
    df0=cbind(df0,dfPartial)
    
    df[[j]]<-df0
    
  } #end of loop for different 'step's
  
  
  return(df);
  
}

```

**Configuración**

```{r, echo = T}

#presets
seats=2:5;
step=c(1,2); #(2 Sainte-Laguë 1 D'Hondt)
dotsperside=199 #dots <- (dotsperside+1)*(dotsperside+2)/2
threshold=0

```

**Generando los datos**

```{r, echo = T}

#Spatial data

dots <- (dotsperside+1)*(dotsperside+2)/2

df = SpatialData(dotsperside, seats, step)

#df = SpatialData(dotsperside, 5, 1, threshold)

#df = SpatialData(dotsperside, c(3,5,4), c(2,1), threshold)

dfT = SpatialData(dotsperside, seats=5, threshold=.20)


head(df[[1]][sample(1:dots,10,replace=F),]) #sample data for step=1 and seats=5

```

**Regiones del Espacio Electoral**

Las regiones creadas por el reparto de D'Hondt no se corresponden con regiones de Voronoi de los nodos. Asigna correctamente más del 60% de los puntos. El reparto de Sainte-Laguë se aproxima más, más de un 90%, a las regiones de Voronoi pero no llega a ser igual. En D'Hondt el tamaño de las distintas regiones es similar, en Sainte-Laguë los nodos se encuentran en el centro de ellas. Las regiones de Voronoi resultarían si a cada punto se le asignara el nodo más próximo. Para este tipo de reparto se obtienen los mismos resultados si utilizamos la distancia Euclídea, Manhattan o la uniforme.

Se estudia aquí la asignación no sólo en resultado, sino también en el orden de reparto de los escaños, y se dibujan diagramas que muestran las regiones del Espacio Electoral divididas en subregiones para cada posible ordenación de la asignación. El diagrama de las subregiones visibiliza de manera bastante destacable la geometría de las regiones electorales.

```{r, echo = T}

#Allocation

a1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Allocated)))+
  theme_bw()+
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="D'Hondt Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

a2 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(Allocated)))+
  theme_bw()+
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

ggtern.multi(a1, a2, cols=2)

#Voronoi

a3 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Manhattan)))+
  theme_bw()+
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Voronoi Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

ggtern.multi(a2, a3, cols=2)


```

**Comparación de las regiones de Voronoi sobre distintas métricas**

Las distancias euclídea, Manhattan y uniforme producen regiones de Voronoi idénticas:

```{r, echo = F}

#equivalence between Voronoi regions using different distances and between those and electoral regions
sum(df[[1]]$Euclid[1:dots]==df[[1]]$Manhattan[1:dots])/dots
sum(df[[1]]$Uniform[1:dots]==df[[1]]$Manhattan[1:dots])/dots
sum(df[[1]]$Uniform[1:dots]==df[[1]]$Euclid[1:dots])/dots

```

**Tamaño de las regiones**

```{r, echo = F}
#size of the regions # 1 ~= dots/nnodes
nnodes=(max(seats)+1)*(max(seats)+2)/2;
RegionSize  = table(df[[1]]$Allocated[1:dots])/(dots/nnodes)
RegionSize2 = table(df[[2]]$Allocated[1:dots])/(dots/nnodes)

par(mfrow=c(2,1))
plot(RegionSize, main="D'Hondt region sizes")
plot(RegionSize2,main="Sainte-Laguë region sizes" )
par(mfrow=c(1,1))

```

**Proporción de resultados no asignados al nodo más cercano**

```{r, echo = F}

#malapportionment
m1 <- ggtern(data=df[[1]],aes(x,y,z,color=Malapportionment)) +
  theme_rgbw() +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey60")+
  labs(x="X",y="Y",z="Z",title="D'Hondt Malapportionment")+
  #scale_colour_grey(na.value = "black", guide = FALSE)
  scale_colour_brewer(palette = "YlGnBu", na.value = "grey60", guide = FALSE)

m2 <- ggtern(data=df[[2]],aes(x,y,z,color=Malapportionment)) +
  theme_rgbw() +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey60")+
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë Malapportionment")+
  scale_colour_brewer(palette = "YlGnBu", na.value = "grey60", guide = FALSE)

ggtern.multi(m1, m2, cols=2)

#points not allocated by D'Hondt in their corresponding Voronoi region
sum(df[[1]]$Malapportionment[1:dots])/dots
#points not allocated by Sainte-Laguë in their corresponding Voronoi region
sum(df[[2]]$Malapportionment[1:dots])/dots

```

**Efecto del umbral sobre las regiones**

```{r, echo = F}

#Threshold effect
t1 <- ggtern(data=dfT[[1]],aes(x,y,z,color=as.factor(Allocated)))+
  theme_bw()+
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Threshold effect on regions")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

ggtern.multi(a1, t1, cols=2)

```

**Regiones para las distintas ordenaciones en la asignación**

```{r, echo = F}

generateOrderColors <- function (colorRGB, seats, validCodes=TRUE) {
  
  #generate order color from alloc order codes
  
  #extract allocation order from allocation order codes:
  OrderCode <-as.matrix(0:(3^seats-1))
  
  OrderRests <- t(matrix(apply(OrderCode, 1, function(x) x %% (3^(1:seats))),ncol=3^seats, nrow=seats))
  #(this is vectorial for OrderRests <- OrderCode %% (3^(1:seats))  )
  
  Order_from_code <- (cbind(OrderRests,0)-cbind(0,OrderRests))[,1:seats]/t(matrix(rep(3^(0:(seats-1)),3^seats),ncol=3^seats,nrow=seats))+1
  vectorOrderCode3 <- 2^(0:(seats-1))
  #decimal codes for colors in nodes
  Code3 = cbind((Order_from_code == 1)%*%as.matrix(vectorOrderCode3),
                (Order_from_code == 2)%*%as.matrix(vectorOrderCode3),
                (Order_from_code == 3)%*%as.matrix(vectorOrderCode3))
  
  #linear transformation to fixed extreme colors
  CodeDecRGB = floor(Code3%*%matrix(colorRGB,3,3, byrow=T)/2^seats)
  
  #hex codes for colors in nodes
  CodeRGB = cbind(matrix("#",3^seats),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))
  CodeRGB = do.call("paste0",as.data.frame(CodeRGB))
  
  #values = CodeRGB[validCodes]
  values = CodeRGB[c(validCodes, 3^seats)] #added one more color bc scale_color_manual() demanded one more color
  #values = CodeRGB[c(1, validCodes)] #added one more color bc scale_color_manual() demanded one more color
  
  
  return(values);
  
}

```

```{r, echo = F}

#ordering subregions
o1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(AllocOrderCode))) +
  theme_bw()+
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),color="black")+
  labs(x="X",y="Y",z="Z",title="Allocation ordering regions")+
  scale_colour_grey(start = 0.1, end = 1, na.value = "black", guide = FALSE)

o2 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(AllocOrderCode))) +
  theme_bw()+
  geom_point(alpha=1) +
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  labs(x="X",y="Y",z="Z",title="They come in colors")+
  scale_colour_manual(values=
      generateOrderColors(colorRGB0,max(seats),sort(unique(df[[1]]$AllocOrderCode))),
      guide=FALSE, na.value="khaki2")

ggtern.multi(o1, o2, cols=2)

```

**Sumas parciales en la asignación**

```{r, echo = F}

#Partial Allocations

p1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(df[[1]]$All2)))+
  theme_bw()+
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="D'Hondt, 2 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,2), guide=FALSE)

p2 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(df[[1]]$All3)))+
  theme_bw()+
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="D'Hondt, 3 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,3), guide=FALSE)

p3 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(df[[1]]$All4)))+
  theme_bw()+
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="D'Hondt, 4 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,4), guide=FALSE)

p4 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(df[[2]]$All2)))+
  theme_bw()+
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë, 2 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,2), guide=FALSE)

p5 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(df[[2]]$All3)))+
  theme_bw()+
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë, 3 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,3), guide=FALSE)

p6 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(df[[2]]$All4)))+
  theme_bw()+
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë, 4 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,4), guide=FALSE)

plist=list(p1,p4,p2,p5,p3,p6)
ggtern.multi(plotlist=plist, cols=3)

```

**Historia de las electiones**

Podemos también representar datos históricos o geográficos de varias elecciones sobre el diagrama.

```{r, echo = F}

#history of election results

VotesData <- function (votes=matrix(0,1), election=matrix(0,1)) {
  
  votes <- prop.table(votes,1)  
  
  x <- votes[,1]
  y <- votes[,2]
  z <- votes[,3]
  
  el=dim(votes)[1]
  label = as.character(election)
  
  
  #assembling a data frame
  df = data.frame(
    
    type = matrix("vote",el,1),
    
    x ,
    y ,
    z ,
    
    label,
    
    election,
    
    color = matrix(NA,el,1)
    
  )
  
  return(df);
  
}

```

```{r, echo = T}

generateSpline <- function (dfvotes, method = "natural") {
  
  #generates a spline curve through elections history
  
  nelect = dim(dfvotes)[1]
  
  splineX <- spline(x=1:nelect,y=dfvotes$x, method=method)
  splineY <- spline(x=1:nelect,y=dfvotes$y, method=method)
  
  dfSpline = matrix(0, length(splineX[[1]]), 3)
  dfSpline[,1] <- splineX[[2]]
  dfSpline[,2] <- splineY[[2]]
  dfSpline[,3] <- 1-dfSpline[,1]-dfSpline[,2]
  dfSpline = as.data.frame(dfSpline)
  names(dfSpline) <- letters[24:26]
  
  return(dfSpline);
  
}

```

```{r, echo = F}

#nelect=10;
#votes=matrix(runif(nelect*3),nelect,3)
#votes <- prop.table(votes,1)

election=as.matrix(seq(from=1979, to=2015, by=4))

#example
#seats=5; step=1;
nelect=10;
votes=matrix(0,nelect,3)
votes[,1]=c(350,430,290,400,390,450,470,360,280,230)
votes[,3]=c(250,180,220,160,140,110, 80, 60, 90,140)
votes[,2]=c( 80, 90,130, 70, 90, 80,120,140,130,110)

#votes[,1]=c(355,437,282,393,408,479,468,356,287,234)
#votes[,3]=c(258,  0,185,144,159, 90, 47, 73,114, 75)
#votes[,2]=c(  0,  0, 82,  0,  0,  0,  0,  0,  0,138)

dfvotes <- VotesData(votes=votes, election=election)

dfSpline <- generateSpline(dfvotes)

```

```{r, echo = T}

ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Allocated)))+
  #theme_rgbw()+
  theme_bw()+
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_point(data=dfvotes,aes(x,y,z),color="orange",alpha=1)+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  geom_text(data=dfvotes,aes(label=label), color="slateblue4", hjust=1.2, vjust=0.3, size=3, angle=90)+ 
  geom_path(data=dfSpline,colour="darkgreen", linetype=1, size=1)+ 
  #geom_path(data=dfvotes,colour="white", linetype=1, size=0.7)+ 
  labs(x="SocLib",y="SocCom",z="LibCon",title="Past Elections")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

```
