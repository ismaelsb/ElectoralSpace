---
title: "A Tomography of Electoral Methods"
output:
  html_document:
    fig_width: 9
    keep_md: yes
    toc: yes
  pdf_document:
    toc: yes
---

## Geometric visualization for proportional electoral methods.

Code available here: <https://github.com/ismaelsb/ElectoralSpace>
 
Interactive web app: <https://ismaelsb.shinyapps.io/ElectoralSpace>



```{r, echo = F, results='hide', message=FALSE, warning=FALSE}
#Uncommmet to install ggtern from an online CRAN repository:
#install.packages("ggtern")
#Load the ggtern library:
library(ggtern)
#library(stats)
set.seed(156) #fix random generation

```

```{r, echo = F}

generateNodes <- function(seats){ 
  
  #define nodes
  nnodes = (seats+1)*(seats+2)/2;
  nodes  = matrix(0,nnodes,3);
  t=1;
  for (i in 0:seats){
    for (j in i:seats){
      nodes[t,] = c(i,j-i,seats-j);
      t=t+1;
    }
  }  
  
  index=as.matrix(1:nnodes)
  
  #node labels for seats
  label=cbind(as.character(nodes[,1]),matrix("-",nnodes),as.character(nodes[,2]),matrix("-",nnodes),as.character(nodes[,3]))
  label=do.call("paste0",as.data.frame(label))
  
  
  nodes <- cbind(index,as.data.frame(nodes),label)
  names(nodes) <- c("index",letters[24:26],"label")
  return(nodes);
  
}

```

```{r, echo = F}

generateColors <- function (colorRGB, seats) {
  
  nnodes = (seats+1)*(seats+2)/2;
  nodes <- as.matrix(generateNodes(seats)[,c("x","y","z")])
  #decimal codes for colors in nodes
  Code3 = floor(nodes*255.9/seats) #255.9 avoids seats -> 256 -> HEX #100 case
  #linear transformation to fixed extreme colors
  CodeDecRGB = floor(Code3%*%matrix(colorRGB,3,3, byrow=T)/256)
  #hex codes for colors in nodes
  CodeRGB=cbind(matrix("#",nnodes),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))
  CodeRGB=do.call("paste0",as.data.frame(CodeRGB))
  values=CodeRGB
  
  return(values);
  
}

```

```{r, echo = F}

#colors for palettes
colorRGB1 <- c(242,74,87, 124,218,198, 91,168,246) #c("#f24a57","#7cdac6","#5ba8f6")
colorRGB2 <- c(226,10,23, 100,207,151, 0,112,184) #c("#e20a17","#64cf97","#0070b8")
colorRGB3 <- c(242,74,87, 124,218,198, 2,114,195) #<--
colorRGB4 <- c(256,0,0, 0,256,0, 0,0,256)
colorRGB5 <- c(224,0,0, 96,224,176, 96,128,224)
colorRGB5 <- c(240,0,0, 96,224,176, 96,128,224)
colorRGB6 <- c(256,256,0, 0,256,256, 256,0,256) ##YMC test shifted colours
colorRGB7 <- c(256,256,256, 256,0,0, 0,0,0) #WRB

colorRGB0 <- colorRGB3 #choose color palette

```

```{r, echo = F}

seats=5
NodesData <- generateNodes(max(seats))

```

```{r, echo = F}

alloc <- function(parties, votes, seats, step, threshold=0){
  
  #function for the seat allocation and its ordering
  #computes allocation for several values of seats and divisor step methods
  #with the same quotiens table


  
  votes=votes*(votes>=(threshold*sum(votes)))
  
  if (sum(votes>0)==0) {
    
       votes <- votes*0+1
       #to avoid an error in the share of seats
    
  }
  
  Mst <- max(step)
  Mse <- max(seats,1) #1 to avoid 0
  nquotients=(1+Mst*(Mse-1))
  
  #table with all the quotients needed
  quotienstable <- data.frame( 
    parties    = rep(parties, each = nquotients), 
    quotients  = as.vector(sapply(votes, function(x) 
      x/seq(from=1, to=nquotients) )),
    votesrep   = rep(votes, each = nquotients), 
    #in a tie of quotiens, the party with more votes first
    tiebreak = rep(runif(length(parties)), each = nquotients) #
    #in a tie of votes, first seats allocated at random quotientsthen the nexts seats in the same order
  ) 
  
  SeatsList=list()
  filteredtable =list()
  
  
  for (j in 1:length(step)) {
    
    
    #select from the table of all quotiens the ones whose divisors
    #belong to the current sequence, given 'seats' and 'step'
    select <- rep(seq(from=1, to=1+step[j]*(Mse-1), by=step[j]),length(parties))+
      rep(seq(from=0,to=nquotients*length(parties)-1,by=nquotients),each=Mse)
    
    filteredtable [[j]] <- quotienstable$parties[select][order(-quotienstable$quotients[select], -quotienstable$votesrep[select],quotienstable$tiebreak[select])] #,runif(length(parties))
    
    SeatsList[[j]]<-list()
    
    #a vector of values for seats if you want to compute the partial sums
    for (i in 1:length(seats)){
      
      SeatsList[[j]][[i]]= table(filteredtable[[j]][1:seats[i]])
      
      if (seats[i]==0){
    
        SeatsList[[j]][[i]]=0*SeatsList[[j]][[i]]
        
    
      }

      
    }
    
    names(SeatsList[[j]])[1:length(seats)]<-do.call("paste0",as.data.frame(cbind("divisor step ",step[j]," for ", seats," seats")))
    
    
    SeatsList[[j]][[length(seats)+1]] = as.matrix(filteredtable[[j]][1:Mse]) #ordering
    
    names(SeatsList[[j]])[length(seats)+1]<-paste0("ordering for divisor step ", step[j]," for ", Mse," seats")
    
    
  }
  
  
  return(SeatsList);
  
}

```

```{r, echo = F}

generateDots <- function(dotsperside, method="lattice"){
  
  dots <- (dotsperside+1)*(dotsperside+2)/2
  
  if (method == "cartesian") {
    #Map Cartesian to Ternary to produce a homegeneous simulation
    Rc = matrix(runif(2*dots), nrow=dots, ncol=2)
    R  = matrix(apply(Rc,1, CartesianToTernary), nrow=dots, ncol=3, byrow=TRUE)
  }
  
  else if (method == "ternary") {
    #Ternary simulation. Projects points in[0,1]^3 to the sum(x)=1 hyperplane
    #This creates way more points in the center than in the extremes
    R = matrix(runif(3*dots), nrow=dots, ncol=3)
    R = prop.table(R,1) #rows sum 1
  }
  
  else if (method == "lattice") {
    #lattice of dots
    
    #read this if you want to use dots instead of dotsperside as input variable:
    #if n is dotsperside
    #dots <- (n+1)*(n+2)/2  
    #inverse calculation:
    #n <- floor((sqrt(8*dots+1)-3)/2) #exact
    #n <- floor(sqrt(2*dots)) #aprox
    
    #then redefine number of dots
    #dots <- (n+1)*(n+2)/2
    R <- matrix(0,nrow=dots, ncol=3)
    i <- 1
    for (x in 0:dotsperside){
      
      for (y in 0:(dotsperside-x)){
        
        R[i,]<- c(x,y,dotsperside-x-y)
        i <- i+1
        
      }
    }
    R = prop.table(R,1) #rows sum 1
  }
  
  return(R);
  
}

```

```{r, echo = F}

CartesianToTernary <- function (x) {
  
  #for homogeneous simulation
  #send an subset of [0,1]x[0,1] which is an equilateral triangle to the ternary diagram 
  
  while ((x[1]<=1/2 & x[2]>2*sin(pi/3)*x[1]) | (x[1]>1/2 & x[2]>2*sin(pi/3)*(1-x[1])))
    x=runif(2);
  
  v = cbind(1-x[1]-x[2]/(2*sin(pi/3)),x[2]/sin(pi/3),x[1]-x[2]/(2*sin(pi/3)));
  
  return(v);
  
}

```

```{r, echo = F}

normalizenodes <- function (nodes) {
  
  normnodes <- nodes
  for (i in 1:dim(nodes)[1]){
    normnodes[i,] <- nodes[i,]/norm(as.matrix(nodes[i,]),"F")
  }
  
  normnodes <- as.matrix(normnodes)
  
}


```

```{r, echo = F}

UniformNearest <- function (x, seats, nodes, nnodes) {
  
  Uniform = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,max))
  
  return(Uniform);
  
}

```

```{r, echo = F}

ManhattanNearest <- function (x, seats, nodes, nnodes) {
  
  Manhattan = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,sum))
  
  return(Manhattan);
  
}

```

```{r, echo = F}

EuclidNearest <- function (x, seats, nodes, nnodes) {
  
  Euclid = which.min(apply((nodes/seats - rep(1,nnodes) %*% t(x))^2,1,sum))
  
  return(Euclid);
  
}

```

```{r, echo = F}

OrthodromicNearest <- function (x, seats, nodes, nnodes) {
  
  normnodes <- normalizenodes(nodes)
  Orthodromic = which.min(acos((x/norm(t(x),"F")) %*% t(as.matrix(normnodes))))
  
  return(Orthodromic);
  
}

```

```{r, echo = F}

AllocatedNode <- function (y, nodes, nnodes) {
  
  Node = which.min(apply(abs(nodes - rep(1,nnodes) %*% t(y)),1,max))
  
  return(Node);
  
}

```

```{r, echo = F}

generateOrderColors <- function (colorRGB, seats, validCodes=TRUE) {
  
  #generate order color from alloc order codes
  
  #extract allocation order from allocation order codes:
  OrderCode <-as.matrix(0:(3^seats-1))
  
  OrderRests <- t(matrix(apply(OrderCode, 1, function(x) x %% (3^(1:seats))),ncol=3^seats, nrow=seats))
  #(this is vectorial for OrderRests <- OrderCode %% (3^(1:seats))  )
  
  Order_from_code <- (cbind(OrderRests,0)-cbind(0,OrderRests))[,1:seats]/t(matrix(rep(3^(0:(seats-1)),3^seats),ncol=3^seats,nrow=seats))+1
  vectorOrderCode3 <- 2^(0:(seats-1))
  #decimal codes for colors in nodes
  Code3 = cbind((Order_from_code == 1)%*%as.matrix(vectorOrderCode3),
                (Order_from_code == 2)%*%as.matrix(vectorOrderCode3),
                (Order_from_code == 3)%*%as.matrix(vectorOrderCode3))
  
  #linear transformation to fixed extreme colors
  CodeDecRGB = floor(Code3%*%matrix(colorRGB,3,3, byrow=T)/2^seats)
  
  #hex codes for colors in nodes
  CodeRGB = cbind(matrix("#",3^seats),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))
  CodeRGB = do.call("paste0",as.data.frame(CodeRGB))
  
  #values = CodeRGB[validCodes]
  values = CodeRGB[c(validCodes, 3^seats)] #added one more color bc scale_color_manual() demanded one more color
  #values = CodeRGB[c(1, validCodes)] #added one more color bc scale_color_manual() demanded one more color
  
  
  return(values);
  
}

```

```{r, echo = F}

SpatialData <- function (dotsperside, seats, step=1, threshold=0, method="lattice") {
  
  
  #Generate random electoral results
  R <- generateDots(dotsperside, method=method)
  dots=dim(R)[1]  #dots <- (dotsperside+1)*(dotsperside+2)/2
  
  Seats=max(seats)
  
  #nodes
  nodes  <- as.matrix(generateNodes(Seats)[,c("x","y","z")])
  nnodes <- (Seats+1)*(Seats+2)/2;
  
  #Indexes for Voronoi regions
  Uniform   = apply(R, 1, UniformNearest,   seats=Seats, nodes = nodes, nnodes=nnodes)
  Manhattan = apply(R, 1, ManhattanNearest, seats=Seats, nodes = nodes, nnodes=nnodes)
  Euclid    = apply(R, 1, EuclidNearest,    seats=Seats, nodes = nodes, nnodes=nnodes)
  Orthodromic=apply(R, 1, OrthodromicNearest,seats=Seats,nodes = nodes, nnodes=nnodes)
  
  
  #allocate seats
  AllocStructure <- apply(R, 1, function(x) alloc(as.character(1:3), x, seats, step, threshold))
  #input a vector of values for seats of to compute partial sums
  
  df=list() #list of dataframes, one for each 'step' value
  
  #loop for diferent 'step's
  for (j in 1:length(step)){
    
    #allocation
    AllocPartial=matrix(0,dots,length(seats))
    
    for (i in 1:length(seats)){
      
      S = t(matrix(sapply(AllocStructure, function(x) x[[j]][[i]]),nrow=3,ncol=dots))
      
      nodes_sub <- as.matrix(generateNodes(seats[i])[,c("x","y","z")])
      
      AllocPartial[,i] = apply(S, 1, AllocatedNode, nodes=nodes_sub, nnodes=(seats[i]+1)*(seats[i]+2)/2)
      
    }
    
    #allocation order
    #computes allocation ordering for max(seats) in each step value
    AllocOrder = t(matrix(sapply(AllocStructure, function(x) as.integer(x[[j]][[length(seats)+1]])),nrow=Seats,ncol=dots))
    vectorOrderCode=as.matrix(3^(0:(Seats-1)))
    #this coding highlights the last seats over the first ones
    # so that there is contrast between adjacent regions
    AllocOrderCode = (matrix(AllocOrder, ncol=Seats)-1) %*% as.matrix(vectorOrderCode)
    
    dfPartial=as.data.frame(AllocPartial)
    names(dfPartial) <- do.call(paste0,as.data.frame(cbind("All",seats)))
    names(dfPartial)[which(seats==Seats)] <- "Allocated"
    
    #assembling a data frame
    df0 = data.frame(
      
      
      x             = as.matrix(R[,1]),
      y             = as.matrix(R[,2]),
      z             = as.matrix(R[,3]),
      
      Sx            = S[,1],
      Sy            = S[,2],
      Sz            = S[,3],
      
      Euclid,
      Manhattan,
      Uniform,
      Orthodromic,
      
      Malapportionment = AllocPartial[1:dots,length(seats)] != Euclid[1:dots],
      Malapportionment2 = AllocPartial[1:dots,length(seats)] != Orthodromic[1:dots],
      
      AllocOrderCode
      
      
    )
    
    df0=cbind(df0,dfPartial)
    
    df[[j]]<-df0
    
  } #end of loop for different 'step's
  
  
  return(df);
  
}

```

```{r, echo = F}

#presets
seats=2:5;
step=c(1,2); #(2 Sainte-Laguë 1 D'Hondt)
dotsperside=199 #dots <- (dotsperside+1)*(dotsperside+2)/2
threshold=0

```

```{r, echo = F}

#Spatial data

dots <- (dotsperside+1)*(dotsperside+2)/2

df = SpatialData(dotsperside, seats, step)

#df = SpatialData(dotsperside, 5, 1, threshold)

#df = SpatialData(dotsperside, c(3,5,4), c(2,1), threshold)

dfT = SpatialData(dotsperside, seats=5, threshold=.20)


#head(df[[1]][sample(1:dots,10,replace=F),]) #sample data for step=1 and seats=5

```

**Drawing the electoral regions**

When talking about the electoral system and electoral reforms there is mainly two kinds of systems: the majoritarian and the proportional systems. In majoritarian electoral systems only a candidate and party is represented in each district. This leaves minority parties, or parties whose voters are not concentrated in a territory, unrepresented. Proportional systems though tend to concede representation to more parties. In any of the cases, electoral methods don't belong to a pure kind, so there is a continuum of shades and people often complain about the porportionality of the systems and demand 'one person, one vote'. They may be wanting equality in the value of their votes and they usually want this to get achieved by allocating seats to territories by their population. There are always problems with the numbers of seats allocated to the less populated territories. But there is an even more important and complex problem: the ability of the system to represent minority parties, primarily when their voters are dispersed. This can be solved if all districts in the elections have a considerable number of seats, for if we have districts with a few seats, there is no way without wasting the votes of lesser parties.

Knowing all this we can still do a little engineering with the mathematical method for the partitions of seats. The choose of a method can be blamed for the overall unfairness of the electoral system, but don't let us tarnish the memory of Victor d'Hondt for the illness of the whole system. At this point let's wonder how a fair discrete partition method should be. It must be an axiom that for each sharing of votes identical to the proportions of a discrete (integer) partition summing the total number of seats, this discrete partition should be allocated. Moreover, I say the proportion of seats allocated to each party and the proportion of votes to each party in the districts must be as close as possible.

Let's figure out a 'drawing' technique for electoral methods. We are restricted to two dimesions (on a paper or a screen). If we draw all the posible outcomes of an election with only two parties we can colour the zones in which the configuration of the partition of the seats is the same, with the same colour, from, say, red to blue, passing through the intermediate shades. Soon we notice that proportional outcomes give the same allocation of seats, so we don't need to paint all the points, just a line segment, from 0% to 100% of the votes obtained by one of the parties. Drawing a line won't give us plenty of information, and we still have one dimension left. We can try to plot the results for three parties, one point for each set of proportional electoral outcomes. Thus we get a ternary diagram representing the projective space for the positive quadrant of the tridimensional space, this is the so called 3-simplex and the barycentric coordinates. If we color the regions of electoral results by its closeness to a seat allocation node, it should be something like this:

```{r, echo = F, warning=FALSE}
#plot example
ex1 <- ggtern(data=data.frame(x=0.2,y=0.3,z=0.5),aes(x,y,z))+
  theme_arrowdefault()+geom_point()

```

```{r, echo = F, warning=FALSE}

#plot nodes for seat allocation
n1 <- ggtern(data=NodesData,aes(x,y,z,color=as.factor(index)))+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1, size=5)+
  geom_text(aes(label=label,color=as.factor(index)), hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Nodes for seat allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")


#ggtern.multi(ex1, n1, cols=2)
grid.arrange(grobs = list(ex1, n1), ncol=2)

#Voronoi

v1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Manhattan)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Voronoi Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

#Orthodromic Voronoi

v2 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(Orthodromic)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Orthodromic Voronoi Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")


#Differences between planar and orthodromic Voronoi regions

v12 <- ggtern(data=df[[1]],aes(x,y,z,color=Malapportionment!=Malapportionment2)) +
  #theme_rgbw() +
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey30")+
  labs(x="X",y="Y",z="Z",title="Planar vs Orthodromic regions")+
  #scale_colour_grey(na.value = "black", guide = FALSE)
  scale_colour_brewer(palette = "Greys", na.value = "grey60", guide = FALSE)


#ggtern.multi(v1, v2, cols=2)
grid.arrange(grobs = list(v1, v2), ncol=2)
#ggtern.multi(v12, cols=1)
grid.arrange(grobs = list(v12), ncol=1)

```

For four parties we'd need a tetrahedron. The diagram is usefull for visualizing possible seats at stake when the results are close to the borders between two or more regions.

We have used different types of distances for the measure of the 'closeness'. Different distances can produce different Voronoi regions: those created by distances on the projective space of the simplex (Euclidean, Manhattan and Uniform) give the same regions (first diagram), and those created by the orthodromic distance on the unit sphere (normalized vectors) give the regions of the second diagram.

Voronoi regions would be obtained by a method always allocating the nearest node. A Voronoi allocation method should solve the ties between two or more parties when the result is in a border in the same way the quotients methods do (by the total number of votes, and if the tie persists, at random).

```{r, echo = F}

#equivalence between Voronoi regions using different distances and between those and electoral regions
sum(df[[1]]$Euclid[1:dots]==df[[1]]$Manhattan[1:dots])/dots
sum(df[[1]]$Uniform[1:dots]==df[[1]]$Manhattan[1:dots])/dots
sum(df[[1]]$Uniform[1:dots]==df[[1]]$Euclid[1:dots])/dots

#Differences between planar and orthodromic Voronoi regions
sum(df[[1]]$Euclid[1:dots]==df[[1]]$Orthodromic[1:dots])/dots


```


**Highest averages methods**

Now is when we wonder if the well known D'Hondt method somehow resembles our goal. This method of sharing seems pretty straightforward and natural when is firstly explained to us, but this is why it got a bad reputation:


```{r, echo = F, warning=FALSE}

#D'Hondt Allocation
a1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Allocated)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="D'Hondt Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

#ggtern.multi(a1, cols=1)
grid.arrange(grobs = list(a1), ncol=1)

#malapportionment
m1 <- ggtern(data=df[[1]],aes(x,y,z,color=Malapportionment)) +
  #theme_rgbw() +
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey60")+
  labs(x="X",y="Y",z="Z",title="D'Hondt Malapportionment")+
  #scale_colour_grey(na.value = "black", guide = FALSE)
  scale_colour_brewer(palette = "YlGnBu", na.value = "grey60", guide = FALSE)

#orthodromic malapportionment
om1 <- ggtern(data=df[[1]],aes(x,y,z,color=Malapportionment2)) +
  #theme_rgbw() +
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey60")+
  labs(x="X",y="Y",z="Z",title="D'Hondt Malapportionment (Orthodromic)")+
  #scale_colour_grey(na.value = "black", guide = FALSE)
  scale_colour_brewer(palette = "YlGnBu", na.value = "grey60", guide = FALSE)

#ggtern.multi(m1, om1, cols=2)
grid.arrange(grobs = list(m1, om1), ncol=2)

#points not allocated by D'Hondt in their corresponding Voronoi region
sum(df[[1]]$Malapportionment[1:dots])/dots
#points not allocated by D'Hondt in their corresponding orthodromic Voronoi region
sum(df[[1]]$Malapportionment2[1:dots])/dots

```

The diagram for malaportionment shows the proportion of results not allocated to the nearest node.


Another way of wronging the lesser parties is by setting an artificial entry threshold above the effective threshold of the method:

```{r, echo = F, warning=FALSE}

#Threshold effect
t1 <- ggtern(data=dfT[[1]],aes(x,y,z,color=as.factor(Allocated)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Threshold effect on regions")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

#ggtern.multi(a1, t1, cols=2)
grid.arrange(grobs = list(a1, t1), ncol=2)

```

Clearly, this method shows a bias towards extreme nodes. Again, we shouldn't blame highest averages methods for this. Luckily Sainte-Laguë came to help us:

```{r, echo = F, warning=FALSE}

#Sainte-Laguë allocation
a2 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(Allocated)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

#ggtern.multi(a2, cols=1)
grid.arrange(grobs = list(a2), ncol=1)

#orthodromic 
m2 <- ggtern(data=df[[2]],aes(x,y,z,color=Malapportionment)) +
  #theme_rgbw() +
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey60")+
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë Malapportionment")+
  scale_colour_brewer(palette = "YlGnBu", na.value = "grey60", guide = FALSE)

#orthodromic malapportionment
om2 <- ggtern(data=df[[2]],aes(x,y,z,color=Malapportionment2)) +
  #theme_rgbw() +
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey60")+
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë Malapportionment (Orthodromic)")+
  #scale_colour_grey(na.value = "black", guide = FALSE)
  scale_colour_brewer(palette = "YlGnBu", na.value = "grey60", guide = FALSE)

#ggtern.multi(m2, om2, cols=2)
grid.arrange(grobs = list(m2, om2), ncol=2)

#points not allocated by Sainte-Laguë in their corresponding Voronoi region
sum(df[[2]]$Malapportionment[1:dots])/dots
#points not allocated by Sainte-Laguë in their corresponding orthodromic Voronoi region
sum(df[[2]]$Malapportionment2[1:dots])/dots

```

```{r, echo = F}

#size of the regions # 1 ~= dots/nnodes
nnodes=(max(seats)+1)*(max(seats)+2)/2;
RegionSize  = table(df[[1]]$Allocated[1:dots])/(dots/nnodes)
RegionSize2 = table(df[[2]]$Allocated[1:dots])/(dots/nnodes)

par(mfrow=c(2,1))
plot(RegionSize, main="D'Hondt region sizes")
plot(RegionSize2,main="Sainte-Laguë region sizes" )
par(mfrow=c(1,1))

```

This is getting close. Still those shapes...

The regions created by D'Hondt method aren't the same as the Voronoi regions created by the lattice of nodes. This method allocates more than 60% of the points correctly whereas Sainte-Laguë method is, in more than 90% of the points, similar to Voronoi. In D'Hondt the sizes of the regions are similar, but Sainte-Laguë produces regions centered on the nodes.

Highest averages methods produce regions with borders in angular sections. Voronoi borders are given by segment sections.

We study here not only the result of allocation, but also the ordering in the allocation of seats, and so we plot a diagram for the regions of different allocation orderings in the Electoral Space as subregions of the allocation ones. This diagram visualizes in a remarkable way the geometry of the Electoral Space:

```{r, echo = F, warning=FALSE}

#ordering subregions
o1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(AllocOrderCode))) +
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),color="black")+
  labs(x="X",y="Y",z="Z",title="Allocation ordering regions")+
  scale_colour_grey(start = 0.1, end = 1, na.value = "black", guide = FALSE)

o2 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(AllocOrderCode))) +
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1) +
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  labs(x="X",y="Y",z="Z",title="They come in colors")+
  scale_colour_manual(values=
      generateOrderColors(colorRGB0,max(seats),sort(unique(df[[1]]$AllocOrderCode))),
      guide=FALSE, na.value="khaki2")

#ggtern.multi(o1, o2, cols=2)
grid.arrange(grobs = list(o1, o2), ncol=2)

```

Let's see some diagrams for different number of seats:

```{r, echo = F, warning=FALSE}

#Partial Allocations

p1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(df[[1]]$All2)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="D'Hondt, 2 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,2), guide=FALSE)

p2 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(df[[1]]$All3)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="D'Hondt, 3 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,3), guide=FALSE)

p3 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(df[[1]]$All4)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="D'Hondt, 4 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,4), guide=FALSE)

p4 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(df[[2]]$All2)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë, 2 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,2), guide=FALSE)

p5 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(df[[2]]$All3)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë, 3 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,3), guide=FALSE)

p6 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(df[[2]]$All4)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  labs(x="X",y="Y",z="Z",title="Sainte-Laguë, 4 seats")+
  scale_colour_manual(values=generateColors(colorRGB0,4), guide=FALSE)


plist=list(p1,p2,p3,p4,p5,p6)
#ggtern.multi(plotlist=plist, cols=3)
grid.arrange(grobs = plist, ncol=3)

```

We can plot the history of elections in one diagram:

```{r, echo = F}

#history of election results

VotesData <- function (votes=matrix(0,1), election=matrix(0,1)) {
  
  votes <- prop.table(votes,1)  
  
  x <- votes[,1]
  y <- votes[,2]
  z <- votes[,3]
  
  el=dim(votes)[1]
  label = as.character(election)
  
  
  #assembling a data frame
  df = data.frame(
    
    type = matrix("vote",el,1),
    
    x ,
    y ,
    z ,
    
    label,
    
    election,
    
    color = matrix(NA,el,1)
    
  )
  
  return(df);
  
}

```

```{r, echo = F}

generateSpline <- function (dfvotes, method = "natural") {
  
  #generates a spline curve through elections history
  
  nelect = dim(dfvotes)[1]
  
  splineX <- spline(x=1:nelect,y=dfvotes$x, method=method)
  splineY <- spline(x=1:nelect,y=dfvotes$y, method=method)
  
  dfSpline = matrix(0, length(splineX[[1]]), 3)
  dfSpline[,1] <- splineX[[2]]
  dfSpline[,2] <- splineY[[2]]
  dfSpline[,3] <- 1-dfSpline[,1]-dfSpline[,2]
  dfSpline = as.data.frame(dfSpline)
  names(dfSpline) <- letters[24:26]
  
  return(dfSpline);
  
}

```

```{r, echo = F}

#nelect=10;
#votes=matrix(runif(nelect*3),nelect,3)
#votes <- prop.table(votes,1)

election=as.matrix(seq(from=1979, to=2015, by=4))

#example
#seats=5; step=1;
nelect=10;
votes=matrix(0,nelect,3)
votes[,1]=c(350,430,290,400,390,450,470,360,280,230)
votes[,3]=c(250,180,220,160,140,110, 80, 60, 90,140)
votes[,2]=c( 80, 90,130, 70, 90, 80,120,140,130,110)

#votes[,1]=c(355,437,282,393,408,479,468,356,287,234)
#votes[,3]=c(258,  0,185,144,159, 90, 47, 73,114, 75)
#votes[,2]=c(  0,  0, 82,  0,  0,  0,  0,  0,  0,138)

dfvotes <- VotesData(votes=votes, election=election)

dfSpline <- generateSpline(dfvotes)

```

```{r, echo = F, warning=FALSE}

ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Allocated)))+
  #theme_rgbw()+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_point(data=dfvotes,aes(x,y,z),color="orange",alpha=1)+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  geom_text(data=dfvotes,aes(label=label), color="slateblue4", hjust=1.2, vjust=0.3, size=3, angle=90)+ 
  geom_path(data=dfSpline,colour="darkgreen", linetype=1, size=1)+ 
  #geom_path(data=dfvotes,colour="white", linetype=1, size=0.7)+ 
  labs(x="SocLib",y="SocCom",z="LibCon",title="Past Elections")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

```

**Diversity measures: entropy and effective number of parties**

The diagrams below show vote disperion and camera dispersion measured with different diversity indexes: Shannon entropy and Laakso-Taagepera effective number of parties.

```{r, echo = F, warning=FALSE}

modifiedlog <- function(x) {
  
  #modified log function for the calculation of entropy
  #avoids log(0)=NaN
  
  x <- as.matrix(x)
  r<-log(x)
  r[is.finite(r)==F] <-0
  return(r)
  
  }

#Entropy
Seats <- length(seats)
df[[1]][,13+Seats+1] <- rowSums(-df[[1]][,1:3]*modifiedlog(df[[1]][,1:3]))
df[[1]][,13+Seats+2] <- rowSums(-df[[1]][,4:6]/max(seats)*modifiedlog(df[[1]][,4:6]/max(seats)))

#Effective number of parties
df[[1]][,13+Seats+3] <- 1/rowSums((df[[1]][,1:3])^2)
df[[1]][,13+Seats+4] <- 1/rowSums((df[[1]][,4:6]/max(seats))^2)

names(df[[1]])[(13+Seats+1):(13+Seats+4)] <- c('Entropy','CameraEntropy','Parties','CameraParties')

options(warn=-1) 

e1 <- ggtern(data=df[[1]],aes(x,y,z,color=Entropy))+
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  #geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  #geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Votes Entropy")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  #scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")
  scale_colour_gradient2(low='brown3', mid="aquamarine3", high='black', midpoint=log(2), na.value = "grey50", guide = "colourbar")

e2 <- ggtern(data=df[[1]],aes(x,y,z,color=CameraEntropy))+
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  #geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  #geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Camera Entropy")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  #scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")
  scale_colour_gradient2(low='brown3', mid="aquamarine3", high='black', midpoint=log(2), na.value = "grey50", guide = "colourbar")

#ggtern.multi(e1, e2, cols=2)
grid.arrange(grobs = list(e1, e2), ncol=2)


n1 <- ggtern(data=df[[1]],aes(x,y,z,color=Parties))+
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  #geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  #geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Eff. num of parties")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  #scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")
  scale_colour_gradient2(low='brown3', mid="aquamarine3", high='black', midpoint=2, na.value = "grey50", guide = "colourbar")

n2 <- ggtern(data=df[[1]],aes(x,y,z,color=CameraParties))+
  theme_bw()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  #geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  #geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Eff. num of parties")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  #scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")
  scale_colour_gradient2(low='brown3', mid="aquamarine3", high='black', midpoint=2, na.value = "grey50", guide = "colourbar")

#ggtern.multi(n1, n2, cols=2)
grid.arrange(grobs = list(n1, n2), ncol=2)

```

**Largest remainder methods**

Highest average methods give an answer to those who pursue different levels of proportionality. Bias effects can be corrected or reinforced in any direction. But electors still seem to mistrust the quotients in the Highest averages algorithm. When they say 'one person, one vote', one must struggle to get inside their minds and finally notice that they feel comfortable with the simple division. Then total votes divided somehow by the total seats is the quota. And what's with the rests? This is when the largest remainder methods come:

```{r, echo = F}

seats=5;
#Largest remainder method with Hare Quota is Voronoi

```

```{r, echo = F}

alloc <- function(parties, votes, seats, step=1, threshold=0){
  
  #function for Hare Quota seat allocation
  votes=votes*(votes>=(threshold*sum(votes)))
  
  nparties = length(votes)
  
  quota = sum(votes)/seats
  QAllocation = floor(votes/quota)
  rests = votes %% quota
  
  qtable <- data.frame(
    parties = 1:nparties,
    rests,
    votes
  )
  
  if (seats>sum(QAllocation)){
    
    largestRestsParties <- qtable[order(-rests,-votes),]$parties[1:(seats - sum(QAllocation))]
    largestRestsLogic <- is.element(1:nparties, largestRestsParties)
    
  } else {largestRestsLogic <- matrix(F,1,nparties)}
  
  
  Allocation = list(list(QAllocation + largestRestsLogic, matrix(parties[1],seats)))
  #ordering is not taken into account
  
  return(Allocation);
  
}

```

```{r, echo = F, warning=FALSE}


dfH = SpatialData(dotsperside, seats)

df[[2]][,13+Seats+1] <-  dfH[[1]]$Allocated
names(df[[2]])[13+Seats+1] <- "Hare"

#Largest remainder method with Droop Quota

alloc <- function(parties, votes, seats, step=1, threshold=0){
  
  #function for Hare Quota seat allocation
  votes=votes*(votes>=(threshold*sum(votes)))
  
  nparties = length(votes)
  
  quota = sum(votes)/(seats+1)
  QAllocation = floor(votes/quota)
  rests = votes %% quota
  
  qtable <- data.frame(
    parties = 1:nparties,
    rests,
    votes
  )
  
  if (seats>sum(QAllocation)){
    
    largestRestsParties <- qtable[order(-rests,-votes),]$parties[1:(seats - sum(QAllocation))]
    largestRestsLogic <- is.element(1:nparties, largestRestsParties)
    
  } else {largestRestsLogic <- matrix(F,1,nparties)}
  
  
  Allocation = list(list(QAllocation + largestRestsLogic, matrix(parties[1],seats)))
  #ordering is not taken into account
  
  return(Allocation);
  
}

dfD = SpatialData(dotsperside, seats)

df[[1]][,17+Seats+1] <-  dfD[[1]]$Allocated
names(df[[1]])[17+Seats+1] <- "Droop"

#head(dfH[[1]][sample(1:dots,10,replace=F),])
#head(dfH[[1]][sample(1:dots,10,replace=F),])
#NodesData <- generateNodes(max(seats))

lr1 <- ggtern(data=dfD[[1]],aes(x,y,z,color=as.factor(Allocated)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Largest remainder - Droop Quota Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

lr2 <- ggtern(data=dfH[[1]],aes(x,y,z,color=as.factor(Allocated)))+
  #theme_bw()+
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=1)+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="Largest remainder - Hare Quota Allocation")+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value="khaki2")

#ggtern.multi(lr1, lr2, cols=2)
grid.arrange(grobs = list(lr1, lr2), ncol=2)

#malapportionment
mH1 <- ggtern(data=dfH[[1]],aes(x,y,z,color=Malapportionment)) +
  #theme_rgbw() +
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey60")+
  labs(x="X",y="Y",z="Z",title="Hare Malapportionment")+
  #scale_colour_grey(na.value = "black", guide = FALSE)
  scale_colour_brewer(palette = "YlGnBu", na.value = "grey60", guide = FALSE)

#orthodromic malapportionment
mH2 <- ggtern(data=dfH[[1]],aes(x,y,z,color=Malapportionment2)) +
  #theme_rgbw() +
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey60")+
  labs(x="X",y="Y",z="Z",title="Hare Malapportionment (Orthodromic)")+
  #scale_colour_grey(na.value = "black", guide = FALSE)
  scale_colour_brewer(palette = "YlGnBu", na.value = "grey60", guide = FALSE)

#ggtern.multi(mH1, mH2, cols=2)
grid.arrange(grobs = list(mH1, mH2), ncol=2)

#points not allocated by Hare in their corresponding Voronoi region
sum(dfH[[1]]$Malapportionment[1:dots])/dots
#points not allocated by Hare in their corresponding orthodromic Voronoi region
sum(dfH[[1]]$Malapportionment2[1:dots])/dots

```

So largest remainder method with Hare Quota is similar to Voronoi allocation. Hare quota gives the nearest allocation to each share of votes. Its allocation regions are the Voronoi regions given by the seat allocation nodes. Differences are only observed in the boundaries because we have not considered the way ties break when using the distance functions.

Then there are interests in biasing the results towards the greatest parties, and that's why Droop-Hagenbach–Bischoff method exists.

Hare quota is pretty close to Sainte-Laguë and Droop quota is so to D'Hondt, as can be seen in the next diagrams:

```{r, echo = F, warning=FALSE}

#Droop vs D'Hondt

diff1 <- ggtern(data=df[[1]],aes(x,y,z,color=Allocated!=Droop)) +
  #theme_rgbw() +
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y,z),alpha=0.8,color="grey30")+
  labs(x="X",y="Y",z="Z",title="Droop vs D'Hondt regions")+
  #scale_colour_grey(na.value = "black", guide = FALSE)
  scale_colour_brewer(palette = "Greys", na.value = "grey60", guide = FALSE)

diff2 <- ggtern(data=df[[2]],aes(x,y,z,color=Allocated!=Hare)) +
  #theme_rgbw() +
  theme_minimal()+
  theme(plot.title = element_text(hjust = 0.5)) +
  geom_point(alpha=0.8) +
  geom_point(data=NodesData,aes(x,y),alpha=0.8,color="grey30")+
  labs(x="X",y="Y",z="Z",title="Hare vs Sainte-Laguë regions")+
  #scale_colour_grey(na.value = "black", guide = FALSE)
  scale_colour_brewer(palette = "Greys", na.value = "grey60", guide = FALSE)

#ggtern.multi(diff1, diff2, cols=2)
grid.arrange(grobs = list(diff1, diff2), ncol=2)

#Droop vs D'Hondt
sum(df[[1]]$Allocated==df[[1]]$Droop)/dots
#Hare vs Sainte-Laguë
sum(df[[2]]$Allocated==df[[2]]$Hare)/dots

```

Finally let's take a look at the numbers. Here is an example of allocation:

```{r, echo = F}

alloc <- function(parties, votes, seats, step, threshold=0){
  
  #function for the seat allocation and its ordering
  #computes allocation for several values of seats and divisor step methods
  #with the same quotiens table
  votes=votes*(votes>=(threshold*sum(votes)))
  Mst <- max(step)
  Mse <- max(seats)
  nquotients=(1+Mst*(Mse-1))
  
  #table with all the quotients needed
  quotienstable <- data.frame( 
    parties    = rep(parties, each = nquotients), 
    quotients  = as.vector(sapply(votes, function(x) 
      x/seq(from=1, to=nquotients) )),
    votesrep   = rep(votes, each = nquotients)
  ) 
  
  SeatsList=list()
  filteredtable =list()
  
  
  for (j in 1:length(step)) {
    
    
    #select from the table of all quotiens the ones whose divisors
    #belong to the current sequence, given 'seats' and 'step'
    select <- rep(seq(from=1, to=1+step[j]*(Mse-1), by=step[j]),length(parties))+
      rep(seq(from=0,to=nquotients*length(parties)-1,by=nquotients),each=Mse)
    
    filteredtable [[j]] <- quotienstable$parties[select][order(-quotienstable$quotients[select], -quotienstable$votesrep[select])]
    
    SeatsList[[j]]<-list()
    
    #a vector of values for seats if you want to compute the partial sums
    for (i in 1:length(seats)){
      SeatsList[[j]][[i]]= table(filteredtable[[j]][1:seats[i]])
    }
    
    names(SeatsList[[j]])[1:length(seats)]<-do.call("paste0",as.data.frame(cbind("divisor step ",step[j]," for ", seats," seats")))
    
    
    SeatsList[[j]][[length(seats)+1]] = as.matrix(filteredtable[[j]][1:Mse]) #ordering
    
    names(SeatsList[[j]])[length(seats)+1]<-paste0("ordering for divisor step ", step[j]," for ", Mse," seats")
    
    
  }
  
  
  return(SeatsList);
  
}

```

```{r, echo = T}

#Allocation example (step=2 Sainte-Laguë; step=1 D'Hondt)
votes <- sample(1:1000, 3) 
votes
#alloc(letters[1:3], votes, seats=5, step=1)
#alloc(letters[1:3], votes, seats=c(3,5,4), step=2:1, threshold=0.5)
alloc(letters[1:3], votes, 9, c(1,2), .05) #print seats sum and allocation

```

Sample of the data:

```{r, echo = T}

#dots <- (dotsperside+1)*(dotsperside+2)/2

#df = SpatialData(dotsperside, seats, step)
#df = SpatialData(dotsperside, 5, 1, threshold)
#df = SpatialData(dotsperside, c(3,5,4), c(2,1), threshold)
#dfT = SpatialData(dotsperside, seats=5, threshold=.20)

head(df[[1]][sample(1:dots,10,replace=F),]) #sample data for step=1 and seats=5

```

**Borders for highest averages methods**

The border between two adjacent D'Hondt allocation regions R1 and R2 in the Electoral Space (simplex Σxi=1, 0≤xi≤1) for p parties and s seats, with allocation S1=(s11, ... , s1p) and S2=(s21, ... , s2p), Σs1k=Σs2k=S, dManhattan(S1,S2)=2, s1i≠s2i and s1j≠s2j for some i,j, i≠j, is given by the hyperplane b•xi-a•xj=0, Σx=1, with a=max(s1i,s2i) and b=max(s1j,s2j).

The border between three adjacent regions R1, R2 and R3 with allocation S1=(s11, ... , s1p), S2=(s21, ... , s2p) and S3=(s31, ... , s3p), Σs1k=Σs2k=Σs3k=S, dManhattan(Sm,Sn)=2, m,n=1,2,3, m≠n; smi≠sni and smj≠snj for some i,j, i≠j, is given by the hyperplane {b•xi-a•xj=0, c•xi-a•xk=0, c•xj-b•xk=0, Σx=1} with a=max(s1i,s2i,s3i), b=max(s1j,s2j,s3j) and c=max(s1k,s2k,s3k).

In the case of 3 parties, those lasts borders are points with coordinates (a,b,c)/(a+b+c) ~ (a,b,c), for each intersection of regions. Such points can lay either on the discrete lattice with sum s+1 or on the discrete lattice with sum s+2, for in each intersection, either two or three parties could easily grow by 1 their representation staying in the neighborhood, in respect to the granted minima for that neighborhood. The granted minimum shares sum:

* s-1, for lattice s+2 internal points or lattice s+1 external points;
* s-2, for lattice s+1 internal points;
* s, for lattice s+2 external points;

Two parties can grow on lattice s+1 external points, three parties can grow on every internal point, and no party can grow con lattice s+2 external point, then those are not border points (see diagram), and then, border points of the form (a,b,c) sum either s+1 or s+2.

For Sainte-Laguë or any different than one divisor step, the vectors (a,b,c) are composed by the particular divisors of the method corresponding to the numbers of seats. The points on lattices for sum s+1 or sum s+2 are replaced by vectors of divisors whose indexes sum is s+1 or s+2.

Let's represent in the next diagramns the theoretical borders for the regions. the black points are on the discrete lattice s+1 while the red ones are on the discrete lattice s+2. The borders are the result of the superposition of both lattices. It can be seen that the borders obtained by theoretical means are identical to the ones obtained by the previous simulations. Theoretical regions are computed much faster than simulations.

```{r, echo = F}

generateBorderLattice <- function ( seats, step ) {
  
  divisor <- seq(from=1, to=1+step*(seats+2-1), by=step)
  divisor <- c(0,divisor)
  
  counter <- 1
  borderpoint <- matrix(0,nrow=(seats+3)^2,ncol=4)
  # (seats+2)*(seats+3)/2 + (seats+3)*(seats+4)/2 = (seats+3)^2
  # (corners are counted and registered twice)
  
  #every sum seats+1 border points -> (seats+2)*(seats+3)/2
  #surplus 1 points
  for (i in 0:(seats+1)){
    
    for (j in 0:(seats+1-i)){
      
      d1 <- divisor[i+1] # +1 because vector element divisor[1]=0
      d2 <- divisor[j+1]
      d3 <- divisor[seats+1-i-j+1]
      
      borderpoint[counter,] <- matrix(c(d1,d2,d3,1))
      counter <- counter+1
      
    }
    
  }
  
  #every sum seats+2 border points -> (seats+3)*(seats+4)/2
  #surplus 2 points
  for (i in 0:(seats+2)){
    
    for (j in 0:(seats+2-i)){
      
      d1 <- divisor[i+1]
      d2 <- divisor[j+1]
      d3 <- divisor[seats+2-i-j+1]
      
      borderpoint[counter,] <- matrix(c(d1,d2,d3,2))
      counter <- counter+1
      
    }
    
  }
  
  
  
  borderpoint <- as.data.frame(borderpoint)
  names(borderpoint) <- c('x','y','z','surplus')
  
  return(borderpoint)
  
}

```

```{r, echo = F}

generateBorderLines <- function ( seats, step=1 ) {
  
  divisor <- seq(from=1, to=1+step*(seats+2-1), by=step)
  divisor <- c(0,divisor)
  
  dB0 <- generateBorderLattice(seats,1) #1 instad of step. Will be converted later
  dB <- generateBorderLattice(seats,step) 
  Bl <- matrix(0,nrow=3*(seats+1)*(seats+2)/2+3*(seats+1)+3,ncol=6)
  #number of edges: 6 per hexagon (counted twice);
  #                 2 per external hexagon (counted once)
  #                 3 autoedges on the corners (needed)
  
  #edges form each surplus 1 point to the 3 adjacent suplus 2 points:

  #first of all we use the lattice with step 1 in order to get the divisors
  Bl[,1] <- rep(dB0[dB$surplus==1,1],each=3)
  Bl[,2] <- rep(dB0[dB$surplus==1,2],each=3)
  Bl[,3] <- rep(dB0[dB$surplus==1,3],each=3)
  
  Id3 <- matrix(rep(c(1,0,0,0,1,0,0,0,1),(seats+2)*(seats+3)/2),ncol=3, byrow=T)
  
  # surplus 1 to adjacent surplus 2
  Bl[,4:6] <- divisor[Bl[,1:3]+Id3+1]
  
  #alternative method
  #dBl <- dB0 #(without using dB0)
  #extToint <- (Bl[,1:3]!=0)*Id3  #remove external points growing to internal points
  #Bl[,4:6] <- Bl[,1:3]+Id3+(step-1)*extToint
  # external points grow by 1 to inernal points
  # external points grow by step to external points
  # internal points always grow by step
  
  #Now we can set the surplus 1 points to the lattice with step
  Bl[,1] <- rep(dB[dB$surplus==1,1],each=3)
  Bl[,2] <- rep(dB[dB$surplus==1,2],each=3)
  Bl[,3] <- rep(dB[dB$surplus==1,3],each=3)
  
  Bl <- as.data.frame(Bl)
  names(Bl) <- c('x','y','z', 'xend','yend','zend') #extrem points for an edge
  
  return(Bl)
  
}

```

```{r, echo = F}

generateHexagonData <- function(seats, step=1) {
  
  divisor <- seq(from=1, to=1+step*(seats+2-1), by=step)
  divisor <- c(0,divisor)
  
  NodesData <- generateNodes(seats)
  
  hexagon <- matrix(0,nrow=(seats+1)*(seats+2)/2, ncol=6*3)
  
  for (i in 1:((seats+1)*(seats+2)/2)){
    
    n <- NodesData[i,2:4] #node
    hexagon[i,] <- rep(c(n[[1]],n[[2]],n[[3]]),6)+c(1,0,0, 1,0,1, 0,0,1, 0,1,1, 0,1,0, 1,1,0)
    hexagon[i,] <- divisor[hexagon[i,]+1]
    
  }
  
  dhex <- as.data.frame(cbind(rep(1:((seats+1)*(seats+2)/2),each=6), matrix(t(hexagon),nrow=6*(seats+1)*(seats+2)/2, ncol=3, byrow=T),
                              rep(NodesData$x,each=6),rep(NodesData$y,each=6),rep(NodesData$z,each=6)))
  
  names(dhex) <- c('hex','x','y','z','nx','ny','nz')
  
  return(dhex)
  
}

```

```{r, echo = F, warning=FALSE}

plotallocation <- function (seats, step=1, colorRGB0=c(242,74,87, 124,218,198, 2,114,195), alpha=0.75) {
  
  NodesData <- generateNodes(seats)
  dhex <- generateHexagonData(seats, step)
  
  polygons <- ggtern(data=dhex, aes(x, y, z)) + theme_nomask()
  #+ theme_minimal()
  
  for (i in 1:((seats+1)*(seats+2)/2)){
    
    polygons <- polygons + geom_polygon(aes(fill=hex, group=hex), data=dhex[dhex==i,] , fill=generateColors(colorRGB0,seats)[i], colour='grey40', size=.7, alpha=alpha)
    
  }
  
  polygons <- polygons + geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
    geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
    labs(x="X",y="Y",z="Z",title="")
  
  return(polygons)
  
}

```

```{r, echo = F, warning=FALSE}

seats=5
step=1

NodesData <- generateNodes(seats)

dfB <- generateBorderLattice(seats, step) 

#dfB[,1:3]/rowSums(dfB[,1:3]) #integer to racional

dfBl <- generateBorderLines(seats, step)

#ggtern( data=dfB, aes(x,y,z))+ 
#  geom_point()

bl1 <- ggtern( data=dfBl, aes(x,y,z,xend=xend,yend=yend,zend=zend))+ 
  geom_segment() + theme_minimal()

#ggtern(data=dfB, aes(x,y,z))+
#  geom_point()+
#  geom_segment(data=dfBl,aes(x,y,z,xend=xend,yend=yend,zend=zend))

bpl1 <- ggtern(data=dfB,aes(x,y,z))+
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  #theme_bw()+
  geom_point(alpha=1, color=dfB$surplus)+
  geom_segment(data=dfBl,aes(x,y,z,xend=xend,yend=yend,zend=zend))+
  geom_point(data=NodesData,aes(x,y,z),color="khaki2")+
  geom_text(data=NodesData,aes(label=label), color="grey30", hjust=0.5, vjust=-0.6, size=4)+ 
  labs(x="X",y="Y",z="Z",title="D'Hondt Allocation")#+
  #geom_polygon(aes(fill=, group=))+
  #scale_colour_grey(start = 0.4, end = 1, na.value = "black", guide = FALSE)
  #scale_colour_manual(values=generateColors(colorRGB0,seats), guide=FALSE, na.value="khaki2")


step=2

dfB <- generateBorderLattice(seats, step)

#dfB[,1:3]/rowSums(dfB[,1:3]) #integer to racional

dfBl <- generateBorderLines(seats, step)

bl2 <- ggtern( data=dfBl, aes(x,y,z,xend=xend,yend=yend,zend=zend))+ 
  geom_segment() + theme_minimal()


#ggtern.multi(bl1, bl2, cols=2)
grid.arrange(grobs = list(bl1, bl2), ncol=2)
bpl1

#Border lines for different number of parties
bl <- NULL

for (i in 1:4){
  
  dfBl <- generateBorderLines(seats=i, step=1)
  bl[[i]] <- ggtern( data=dfBl, aes(x,y,z,xend=xend,yend=yend,zend=zend))+ 
    geom_segment() + theme_minimal()
  
}

for (i in 1:4){
  
  dfBl <- generateBorderLines(seats=i, step=2)
  bl[[i+4]] <- ggtern( data=dfBl, aes(x,y,z,xend=xend,yend=yend,zend=zend))+ 
    geom_segment() + theme_minimal()
  
}

#ggtern.multi(bl[[1]],bl[[5]],bl[[2]],bl[[6]],bl[[3]],bl[[7]],bl[[4]],bl[[8]], cols=4)
grid.arrange(grobs = list(bl[[1]],bl[[2]],bl[[3]],bl[[4]],bl[[5]],bl[[6]],bl[[7]],bl[[8]]), ncol=4)



#polygons

seats <- 5

colorRGB0 <- c(242,74,87, 124,218,198, 2,114,195)

dhex <- generateHexagonData(seats, step)


pol1 <- plotallocation(seats, step=1)

step <-2

pol2 <- plotallocation(seats, step=2)

#ggtern.multi(pol1, pol2, cols=2)
grid.arrange(grobs = list(pol1, pol2), ncol=2)

```

**Effective thresholds for representation**


For D'Hondt method, s seats and p parties, σ:Pᵖ(Q)⁺→Δₛᵖ

Minima for representation:

Min sufficient: inf{β|πᵢ(v)>β⇒σᵢ(v)>0}=1/(s+1)

Max necessary:  sup{β|πᵢ(v)<β⇒σᵢ(v)=0}= 1/(s+p-1)


```{r, echo = F}

# Effective thresholds

EffThresholdTable <- function (maxseats, step=1){
  
  dfBlist <- NULL
  dfBlistQ <- NULL
  
  for (i in 1:maxseats){
    
    dfBlist[[i]] <- generateBorderLattice(seats=i, step)            #integers
    dfBlistQ[[i]] <- dfBlist[[i]][,1:3]/rowSums(dfBlist[[i]][,1:3]) #rationals
    
  }
  
  EffNecThreshold <- NULL
  EffSufThreshold <- NULL
  
  for (i in 1:maxseats){
    
    nonzero1 <- dfBlist[[i]][,1]!=0 & dfBlist[[i]]$surplus==1
    nonzero2 <- dfBlist[[i]][,1]!=0 & dfBlist[[i]]$surplus==2
    
    EffNecThreshold[i] <- min(dfBlistQ[[i]][nonzero1,1])
    EffSufThreshold[i] <- min(dfBlistQ[[i]][nonzero2,1])
    
  }
  
  EffThreshold <- as.data.frame(cbind(1:maxseats,EffNecThreshold, EffSufThreshold))
  names(EffThreshold) <- c('seats','EffNecThreshold','EffSufThreshold')
  
  return(EffThreshold)
  
}


maxseats <- 32
step=1

EffThreshold <- EffThresholdTable(maxseats, step)

ggplot(EffThreshold, aes(seats, EffNecThreshold))+
  theme(plot.title = element_text(hjust = 0.5)) +
  #geom_point(colour='paleturquoise4')+
  scale_x_continuous(breaks=seq(1,maxseats,2))+
  scale_y_continuous(breaks=seq(0,0.5,0.02))+
  geom_line(aes(y=EffNecThreshold), colour='black', alpha=1/3)+
  geom_line(aes(y=EffSufThreshold), colour='black', alpha=1/2)+
  geom_ribbon(aes(ymin=EffNecThreshold,ymax=EffSufThreshold),fill='paleturquoise4', alpha=.85)+
  labs(title='Necessary votes for representation.\n A lighter shade for a greater number of parties, from two in the upper curve.\n Upper curve also for sufficient votes, for any number of parties',
       x='Total number of seats', y='Representation thresholds')+
  #geom_line(aes(y=1/(seats+1)),colour='black', alpha=1/2)+ # suff for 3 parties, already painted
  #geom_line(aes(y=1/(seats+2)),colour='black', alpha=1/3)+  # nec for 3 parties, already painted
  geom_line(aes(y=1/(seats+3)),colour='black', alpha=1/4)+ #theoretical nec thresholds from 3 parties
  geom_line(aes(y=1/(seats+4)),colour='black', alpha=1/5)+
  geom_line(aes(y=1/(seats+5)),colour='black', alpha=1/6)+
  geom_line(aes(y=1/(seats+6)),colour='black', alpha=1/7)+
  geom_line(aes(y=1/(seats+7)),colour='black', alpha=1/8)+
  geom_line(aes(y=1/(seats+8)),colour='black', alpha=1/9)+
  geom_line(aes(y=1/(seats+9)),colour='black', alpha=1/10)+
  geom_line(aes(y=1/(seats+10)),colour='black', alpha=1/11)+
  geom_line(aes(y=1/(seats+11)),colour='black', alpha=1/12)+
  geom_line(aes(y=1/(seats+12)),colour='black', alpha=1/13)+
  geom_line(aes(y=1/(seats+13)),colour='black', alpha=1/14)+
  geom_line(aes(y=1/(seats+14)),colour='black', alpha=1/15)+
  #geom_ribbon(aes(ymin=1/(seats+2),ymax=1/(seats+1)),fill='paleturquoise4', alpha=.85)+
  geom_ribbon(aes(ymin=1/(seats+3),ymax=1/(seats+2)),fill='paleturquoise4', alpha=.85^2)+
  geom_ribbon(aes(ymin=1/(seats+4),ymax=1/(seats+3)),fill='paleturquoise4', alpha=.85^3)+
  geom_ribbon(aes(ymin=1/(seats+5),ymax=1/(seats+4)),fill='paleturquoise4', alpha=.85^4)+
  geom_ribbon(aes(ymin=1/(seats+6),ymax=1/(seats+5)),fill='paleturquoise4', alpha=.85^5)+
  geom_ribbon(aes(ymin=1/(seats+7),ymax=1/(seats+6)),fill='paleturquoise4', alpha=.85^6)+
  geom_ribbon(aes(ymin=1/(seats+8),ymax=1/(seats+7)),fill='paleturquoise4', alpha=.85^7)+
  geom_ribbon(aes(ymin=1/(seats+9),ymax=1/(seats+8)),fill='paleturquoise4', alpha=.85^8)+
  geom_ribbon(aes(ymin=1/(seats+10),ymax=1/(seats+9)),fill='paleturquoise4', alpha=.85^9)+
  geom_ribbon(aes(ymin=1/(seats+11),ymax=1/(seats+10)),fill='paleturquoise4', alpha=.85^10)+
  geom_ribbon(aes(ymin=1/(seats+12),ymax=1/(seats+11)),fill='paleturquoise4', alpha=.85^11)+
  geom_ribbon(aes(ymin=1/(seats+13),ymax=1/(seats+12)),fill='paleturquoise4', alpha=.85^12)+
  geom_ribbon(aes(ymin=1/(seats+14),ymax=1/(seats+13)),fill='paleturquoise4', alpha=.85^13)+
  geom_ribbon(aes(ymin=0,ymax=1/(seats+14)),fill='paleturquoise4', alpha=.85^14)+
  theme()


```
```{r, echo = F}

maxseats <- 32
step=2

EffThreshold <- EffThresholdTable(maxseats, step)

ggplot(EffThreshold, aes(seats, EffNecThreshold))+
  #geom_point(colour='paleturquoise4')+
  theme(plot.title = element_text(hjust = 0.5)) +
  scale_x_continuous(breaks=seq(1,maxseats,2))+
  scale_y_continuous(breaks=seq(0,0.5,0.02))+
  geom_line(aes(y=EffNecThreshold), colour='black', alpha=1/2)+
  geom_line(aes(y=EffSufThreshold), colour='black', alpha=1/2)+
  geom_ribbon(aes(ymin=EffNecThreshold,ymax=EffSufThreshold),fill='paleturquoise4', alpha=.85)+
  labs(title='Sainte-Laguë necessary votes for representation.\n Upper curve for sufficient votes.',
       x='Total number of seats', y='Representation thresholds')+
  theme()


```


