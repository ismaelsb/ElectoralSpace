{"name":"Electoral Space","tagline":"Geometric visualization for proportional electoral methodes","body":"# Electoral Space\r\n\r\n## Geometric visualization for proportional electoral methodes.\r\n\r\nCode available here: <https://github.com/ismaelsb/ElectoralSpace>\r\n \r\nInteractive web app: <https://ismaelsb.shinyapps.io/ElectoralSpace>\r\n\r\n**Introduction**\r\n\r\nIn order to represent 3 variables in 2 dimensions in an only way for each set of proportional values, we can use a ternary diagram. You can see this diagram as the projection of the points from the positive quadrant in space onto the hyperplane of points whose sum of coodinates equals 1. The image of this projection is an equilateral triangle. In the same way we can represent two values in a segment and four values in a tetrahedron. This representation is also known by the name of barycentric coordinates in a simplex.\r\n\r\n\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-2-1.png) \r\n\r\n\r\n**Electoral allocation functions (more in the code)**\r\n\r\nA diagram like these can be used to represent the results in political elections in which the votes are shared between 3 parties. Each point in the triangle is represented by three coordinates corresponding the share of votes received by each party. We have a determined number of seats to allocate, and each posible sharing is represented by a highlighted dot (a node) in the triangle and a label with its result. The electoral method would allocate to each electoral result one of the possible sharings of seats. The regions of points to which the same sharing is allocated are represented in the same color. For two parties we'd use a segment. For four, a tetrahedron. The diagram is usefull for visualizing possible seats at stake when the results are close to the borders between two or more regions.\r\n\r\nWe use a function for electoral allocation for different proportional methods and an optional entry threshold.\r\n\r\nWe also show some of the functions used to compute allocations or to plot the diagrams.\r\n\r\n\r\n\r\n\r\n```r\r\ngenerateColors <- function (colorRGB, seats) {\r\n  \r\n  nnodes = (seats+1)*(seats+2)/2;\r\n  nodes <- as.matrix(generateNodes(seats)[,c(\"x\",\"y\",\"z\")])\r\n  #decimal codes for colors in nodes\r\n  Code3 = floor(nodes*255.9/seats) #255.9 avoids seats -> 256 -> HEX #100 case\r\n  #linear transformation to fixed extreme colors\r\n  CodeDecRGB = floor(Code3%*%matrix(colorRGB,3,3, byrow=T)/256)\r\n  #hex codes for colors in nodes\r\n  CodeRGB=cbind(matrix(\"#\",nnodes),format(as.hexmode(CodeDecRGB[,1]),width=2),format(as.hexmode(CodeDecRGB[,2]),width=2),format(as.hexmode(CodeDecRGB[,3]),width=2))\r\n  CodeRGB=do.call(\"paste0\",as.data.frame(CodeRGB))\r\n  values=CodeRGB\r\n  \r\n  return(values);\r\n  \r\n}\r\n```\r\n\r\n\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-6-1.png) \r\n\r\n\r\n```r\r\nalloc <- function(parties, votes, seats, step, threshold=0){\r\n  \r\n  #function for the seat allocation and its ordering\r\n  #computes allocation for several values of seats and divisor step methods\r\n  #with the same quotiens table\r\n  votes=votes*(votes>=(threshold*sum(votes)))\r\n  Mst <- max(step)\r\n  Mse <- max(seats)\r\n  nquotients=(1+Mst*(Mse-1))\r\n  \r\n  #table with all the quotients needed\r\n  quotienstable <- data.frame( \r\n    parties    = rep(parties, each = nquotients), \r\n    quotients  = as.vector(sapply(votes, function(x) \r\n      x/seq(from=1, to=nquotients) )),\r\n    votesrep   = rep(votes, each = nquotients)\r\n  ) \r\n  \r\n  SeatsList=list()\r\n  filteredtable =list()\r\n  \r\n  \r\n  for (j in 1:length(step)) {\r\n    \r\n    \r\n    #select from the table of all quotiens the ones whose divisors\r\n    #belong to the current sequence, given 'seats' and 'step'\r\n    select <- rep(seq(from=1, to=1+step[j]*(Mse-1), by=step[j]),length(parties))+\r\n      rep(seq(from=0,to=nquotients*length(parties)-1,by=nquotients),each=Mse)\r\n    \r\n    filteredtable [[j]] <- quotienstable$parties[select][order(-quotienstable$quotients[select], -quotienstable$votesrep[select])]\r\n    \r\n    SeatsList[[j]]<-list()\r\n    \r\n    #a vector of values for seats if you want to compute the partial sums\r\n    for (i in 1:length(seats)){\r\n      SeatsList[[j]][[i]]= table(filteredtable[[j]][1:seats[i]])\r\n    }\r\n    \r\n    names(SeatsList[[j]])[1:length(seats)]<-do.call(\"paste0\",as.data.frame(cbind(\"divisor step \",step[j],\" for \", seats,\" seats\")))\r\n    \r\n    \r\n    SeatsList[[j]][[length(seats)+1]] = as.matrix(filteredtable[[j]][1:Mse]) #ordering\r\n    \r\n    names(SeatsList[[j]])[length(seats)+1]<-paste0(\"ordering for divisor step \", step[j],\" for \", Mse,\" seats\")\r\n    \r\n    \r\n  }\r\n  \r\n  \r\n  return(SeatsList);\r\n  \r\n}\r\n```\r\n\r\n**Examples of allocation**\r\n\r\n\r\n```r\r\n#Allocation example (step=2 Sainte-Laguë; step=1 D'Hondt)\r\nvotes <- sample(1:1000, 3) \r\nvotes\r\n```\r\n\r\n```\r\n## [1]  77 265 117\r\n```\r\n\r\n```r\r\n#alloc(letters[1:3], votes, seats=5, step=1)\r\n#alloc(letters[1:3], votes, seats=c(3,5,4), step=2:1, threshold=0.5)\r\nalloc(letters[1:3], votes, 9, c(1,2), .05) #print seats sum and allocation\r\n```\r\n\r\n```\r\n## [[1]]\r\n## [[1]]$`divisor step 1 for 9 seats`\r\n## \r\n## a b c \r\n## 1 6 2 \r\n## \r\n## [[1]]$`ordering for divisor step 1 for 9 seats`\r\n##       [,1]\r\n##  [1,] \"b\" \r\n##  [2,] \"b\" \r\n##  [3,] \"c\" \r\n##  [4,] \"b\" \r\n##  [5,] \"a\" \r\n##  [6,] \"b\" \r\n##  [7,] \"c\" \r\n##  [8,] \"b\" \r\n##  [9,] \"b\" \r\n## \r\n## \r\n## [[2]]\r\n## [[2]]$`divisor step 2 for 9 seats`\r\n## \r\n## a b c \r\n## 2 5 2 \r\n## \r\n## [[2]]$`ordering for divisor step 2 for 9 seats`\r\n##       [,1]\r\n##  [1,] \"b\" \r\n##  [2,] \"c\" \r\n##  [3,] \"b\" \r\n##  [4,] \"a\" \r\n##  [5,] \"b\" \r\n##  [6,] \"c\" \r\n##  [7,] \"b\" \r\n##  [8,] \"b\" \r\n##  [9,] \"a\"\r\n```\r\n\r\n\r\n```r\r\ngenerateDots <- function(dotsperside, method=\"lattice\"){\r\n  \r\n  dots <- (dotsperside+1)*(dotsperside+2)/2\r\n  \r\n  if (method == \"cartesian\") {\r\n    #Map Cartesian to Ternary to produce a homegeneous simulation\r\n    Rc = matrix(runif(2*dots), nrow=dots, ncol=2)\r\n    R  = matrix(apply(Rc,1, CartesianToTernary), nrow=dots, ncol=3, byrow=TRUE)\r\n  }\r\n  \r\n  else if (method == \"ternary\") {\r\n    #Ternary simulation. Projects points in[0,1]^3 to the sum(x)=1 hyperplane\r\n    #This creates way more points in the center than in the extremes\r\n    R = matrix(runif(3*dots), nrow=dots, ncol=3)\r\n    R = prop.table(R,1) #rows sum 1\r\n  }\r\n  \r\n  else if (method == \"lattice\") {\r\n    #lattice of dots\r\n    \r\n    #read this if you want to use dots instead of dotsperside as input variable:\r\n    #if n is dotsperside\r\n    #dots <- (n+1)*(n+2)/2  \r\n    #inverse calculation:\r\n    #n <- floor((sqrt(8*dots+1)-3)/2) #exact\r\n    #n <- floor(sqrt(2*dots)) #aprox\r\n    \r\n    #then redefine number of dots\r\n    #dots <- (n+1)*(n+2)/2\r\n    R <- matrix(0,nrow=dots, ncol=3)\r\n    i <- 1\r\n    for (x in 0:dotsperside){\r\n      \r\n      for (y in 0:(dotsperside-x)){\r\n        \r\n        R[i,]<- c(x,y,dotsperside-x-y)\r\n        i <- i+1\r\n        \r\n      }\r\n    }\r\n    R = prop.table(R,1) #rows sum 1\r\n  }\r\n  \r\n  return(R);\r\n  \r\n}\r\n```\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n```r\r\nManhattanNearest <- function (x, seats, nodes, nnodes) {\r\n  \r\n  Manhattan = which.min(apply(abs(nodes/seats - rep(1,nnodes) %*% t(x)),1,sum))\r\n  \r\n  return(Manhattan);\r\n  \r\n}\r\n```\r\n\r\n\r\n\r\n\r\n```r\r\nOrthodromicNearest <- function (x, seats, nodes, nnodes) {\r\n  \r\n  normnodes <- normalizenodes(nodes)\r\n  Orthodromic = which.min(acos((x/norm(t(x),\"F\")) %*% t(as.matrix(normnodes))))\r\n  \r\n  return(Orthodromic);\r\n  \r\n}\r\n```\r\n\r\n\r\n\r\n**Data frame (more in the code)**\r\n\r\n\r\n```r\r\nSpatialData <- function (dotsperside, seats, step=1, threshold=0, method=\"lattice\") {\r\n  \r\n  \r\n  #Generate random electoral results\r\n  R <- generateDots(dotsperside, method=method)\r\n  dots=dim(R)[1]  #dots <- (dotsperside+1)*(dotsperside+2)/2\r\n  \r\n  Seats=max(seats)\r\n  \r\n  #nodes\r\n  nodes  <- as.matrix(generateNodes(Seats)[,c(\"x\",\"y\",\"z\")])\r\n  nnodes <- (Seats+1)*(Seats+2)/2;\r\n  \r\n  #Indexes for Voronoi regions\r\n  Uniform   = apply(R, 1, UniformNearest,   seats=Seats, nodes = nodes, nnodes=nnodes)\r\n  Manhattan = apply(R, 1, ManhattanNearest, seats=Seats, nodes = nodes, nnodes=nnodes)\r\n  Euclid    = apply(R, 1, EuclidNearest,    seats=Seats, nodes = nodes, nnodes=nnodes)\r\n  Orthodromic=apply(R, 1, OrthodromicNearest,seats=Seats,nodes = nodes, nnodes=nnodes)\r\n  \r\n  \r\n  #allocate seats\r\n  AllocStructure <- apply(R, 1, function(x) alloc(as.character(1:3), x, seats, step, threshold))\r\n  #input a vector of values for seats of to compute partial sums\r\n  \r\n  df=list() #list of dataframes, one for each 'step' value\r\n  \r\n  #loop for diferent 'step's\r\n  for (j in 1:length(step)){\r\n    \r\n    #allocation\r\n    AllocPartial=matrix(0,dots,length(seats))\r\n    \r\n    for (i in 1:length(seats)){\r\n      \r\n      S = t(matrix(sapply(AllocStructure, function(x) x[[j]][[i]]),nrow=3,ncol=dots))\r\n      \r\n      nodes_sub <- as.matrix(generateNodes(seats[i])[,c(\"x\",\"y\",\"z\")])\r\n      \r\n      AllocPartial[,i] = apply(S, 1, AllocatedNode, nodes=nodes_sub, nnodes=(seats[i]+1)*(seats[i]+2)/2)\r\n      \r\n    }\r\n    \r\n    #allocation order\r\n    #computes allocation ordering for max(seats) in each step value\r\n    AllocOrder = t(matrix(sapply(AllocStructure, function(x) as.integer(x[[j]][[length(seats)+1]])),nrow=Seats,ncol=dots))\r\n    vectorOrderCode=as.matrix(3^(0:(Seats-1)))\r\n    #this coding highlights the last seats over the first ones\r\n    # so that there is contrast between adjacent regions\r\n    AllocOrderCode = (matrix(AllocOrder, ncol=Seats)-1) %*% as.matrix(vectorOrderCode)\r\n    \r\n    dfPartial=as.data.frame(AllocPartial)\r\n    names(dfPartial) <- do.call(paste0,as.data.frame(cbind(\"All\",seats)))\r\n    names(dfPartial)[which(seats==Seats)] <- \"Allocated\"\r\n    \r\n    #assembling a data frame\r\n    df0 = data.frame(\r\n      \r\n      \r\n      x             = as.matrix(R[,1]),\r\n      y             = as.matrix(R[,2]),\r\n      z             = as.matrix(R[,3]),\r\n      \r\n      Sx            = S[,1],\r\n      Sy            = S[,2],\r\n      Sz            = S[,3],\r\n      \r\n      Euclid,\r\n      Manhattan,\r\n      Uniform,\r\n      Orthodromic,\r\n      \r\n      Malapportionment = AllocPartial[1:dots,length(seats)] != Euclid[1:dots],\r\n      Malapportionment2 = AllocPartial[1:dots,length(seats)] != Orthodromic[1:dots],\r\n      \r\n      AllocOrderCode\r\n      \r\n      \r\n    )\r\n    \r\n    df0=cbind(df0,dfPartial)\r\n    \r\n    df[[j]]<-df0\r\n    \r\n  } #end of loop for different 'step's\r\n  \r\n  \r\n  return(df);\r\n  \r\n}\r\n```\r\n\r\n**Settings**\r\n\r\n\r\n```r\r\n#presets\r\nseats=2:5;\r\nstep=c(1,2); #(2 Sainte-Laguë 1 D'Hondt)\r\ndotsperside=199 #dots <- (dotsperside+1)*(dotsperside+2)/2\r\nthreshold=0\r\n```\r\n\r\n**Generating the data**\r\n\r\n\r\n```r\r\n#Spatial data\r\n\r\ndots <- (dotsperside+1)*(dotsperside+2)/2\r\n\r\ndf = SpatialData(dotsperside, seats, step)\r\n\r\n#df = SpatialData(dotsperside, 5, 1, threshold)\r\n\r\n#df = SpatialData(dotsperside, c(3,5,4), c(2,1), threshold)\r\n\r\ndfT = SpatialData(dotsperside, seats=5, threshold=.20)\r\n\r\n\r\nhead(df[[1]][sample(1:dots,10,replace=F),]) #sample data for step=1 and seats=5\r\n```\r\n\r\n```\r\n##                x          y          z Sx Sy Sz Euclid Manhattan Uniform\r\n## 14193 0.45728643 0.43718593 0.10552764  3  2  0     14        14      14\r\n## 11800 0.35678392 0.42211055 0.22110553  2  2  1     14        14      14\r\n## 6773  0.18592965 0.19095477 0.62311558  1  1  3      8         8       8\r\n## 9930  0.28643216 0.62814070 0.08542714  1  4  0     15        15      15\r\n## 2176  0.05527638 0.15075377 0.79396985  0  0  5      2         2       2\r\n## 18466 0.71859296 0.09045226 0.19095477  4  0  1     19        19      19\r\n##       Orthodromic Malapportionment Malapportionment2 AllocOrderCode All2\r\n## 14193          14             TRUE              TRUE             30    5\r\n## 11800          14            FALSE             FALSE             46    5\r\n## 6773            8            FALSE             FALSE             53    1\r\n## 9930           15             TRUE              TRUE            112    3\r\n## 2176            2             TRUE              TRUE            242    1\r\n## 18466          19            FALSE             FALSE             54    6\r\n##       All3 All4 Allocated\r\n## 14193    9   12        18\r\n## 11800    6    8        14\r\n## 6773     1    2         8\r\n## 9930     7    9        11\r\n## 2176     1    1         1\r\n## 18466   10   13        19\r\n```\r\n\r\n**Electoral Space regions**\r\n\r\nThe regions created by D'Hondt method aren't the same as the Voronoi regions created by the lattice of nodes. This method allocates more than 60% of the points correctly whereas Sainte-Laguë method is, in more than 90% of the points, similar to Voronoi. In D'Hondt the sizes of the regions are similar, but Sainte-Laguë produces regions centered on the nodes. Voronoi regions would be obtained by a method always allocating the nearest node. Those regions are similar if we use Euclidean, Manhattan or uniform distance. A Voronoi allocation method should solve the ties between two or more parties when the result is in a border in the same way the quotients methods do (by the total number of votes, and if the tie persists, at random).\r\n\r\nQuotients method produce regions with borders in angular sections. Voronoi borders are given by segment sections.\r\n\r\nWe study here not only the result of allocation, but also the ordering in the allocation, and so we plot a diagram for the regions of different allocation orderings in the Electoral Space as subregions of the allocation ones.\r\nThis diagram visualizes in a remarkable way the geometry of the Electoral Space.\r\n\r\n\r\n```r\r\n#Allocation\r\n\r\na1 <- ggtern(data=df[[1]],aes(x,y,z,color=as.factor(Allocated)))+\r\n  theme_bw()+\r\n  geom_point(alpha=1)+\r\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\r\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \r\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"D'Hondt Allocation\")+\r\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\r\n  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value=\"khaki2\")\r\n\r\na2 <- ggtern(data=df[[2]],aes(x,y,z,color=as.factor(Allocated)))+\r\n  theme_bw()+\r\n  geom_point(alpha=1)+\r\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\r\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \r\n  labs(x=\"X\",y=\"Y\",z=\"Z\",title=\"Sainte-Laguë Allocation\")+\r\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\r\n  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value=\"khaki2\")\r\n\r\nggtern.multi(a1, a2, cols=2)\r\n```\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-20-1.png) \r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-21-1.png) ![](ElectoralSpace_files/figure-html/unnamed-chunk-21-2.png) \r\n\r\n**Comparing Voronoi regions over different metrics**\r\n\r\nEuclid, Manhattan and Uniform distances produce exactly the same Voronoi regions. Orthodromic distance on the unit sphere produces different regions:\r\n\r\n\r\n```\r\n## [1] 1\r\n```\r\n\r\n```\r\n## [1] 1\r\n```\r\n\r\n```\r\n## [1] 1\r\n```\r\n\r\n```\r\n## [1] 0.9146269\r\n```\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-22-1.png) \r\n\r\n**Size of the regions**\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-23-1.png) \r\n\r\n**Proportion of results not allocated to the nearest node**\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-24-1.png) ![](ElectoralSpace_files/figure-html/unnamed-chunk-24-2.png) \r\n\r\n```\r\n## [1] 0.3691045\r\n```\r\n\r\n```\r\n## [1] 0.08014925\r\n```\r\n\r\n```\r\n## [1] 0.2856219\r\n```\r\n\r\n```\r\n## [1] 0.08333333\r\n```\r\n\r\n**Effect of a threshold on the regions**\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-25-1.png) \r\n\r\n**Regions for different orderings in the allocation**\r\n\r\n\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-27-1.png) \r\n\r\n**Partial sums in the allocation**\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-28-1.png) \r\n\r\n**History of elections**\r\n\r\nWe can also draw historic data from past elections on the diagrams.\r\n\r\n\r\n\r\n\r\n```r\r\ngenerateSpline <- function (dfvotes, method = \"natural\") {\r\n  \r\n  #generates a spline curve through elections history\r\n  \r\n  nelect = dim(dfvotes)[1]\r\n  \r\n  splineX <- spline(x=1:nelect,y=dfvotes$x, method=method)\r\n  splineY <- spline(x=1:nelect,y=dfvotes$y, method=method)\r\n  \r\n  dfSpline = matrix(0, length(splineX[[1]]), 3)\r\n  dfSpline[,1] <- splineX[[2]]\r\n  dfSpline[,2] <- splineY[[2]]\r\n  dfSpline[,3] <- 1-dfSpline[,1]-dfSpline[,2]\r\n  dfSpline = as.data.frame(dfSpline)\r\n  names(dfSpline) <- letters[24:26]\r\n  \r\n  return(dfSpline);\r\n  \r\n}\r\n```\r\n\r\n\r\n\r\n\r\n```r\r\nggtern(data=df[[1]],aes(x,y,z,color=as.factor(Allocated)))+\r\n  #theme_rgbw()+\r\n  theme_bw()+\r\n  geom_point(alpha=1)+\r\n  geom_point(data=NodesData,aes(x,y,z),color=\"khaki2\")+\r\n  geom_point(data=dfvotes,aes(x,y,z),color=\"orange\",alpha=1)+\r\n  geom_text(data=NodesData,aes(label=label), color=\"grey30\", hjust=0.5, vjust=-0.6, size=4)+ \r\n  geom_text(data=dfvotes,aes(label=label), color=\"slateblue4\", hjust=1.2, vjust=0.3, size=3, angle=90)+ \r\n  geom_path(data=dfSpline,colour=\"darkgreen\", linetype=1, size=1)+ \r\n  #geom_path(data=dfvotes,colour=\"white\", linetype=1, size=0.7)+ \r\n  labs(x=\"SocLib\",y=\"SocCom\",z=\"LibCon\",title=\"Past Elections\")+\r\n  #scale_colour_grey(start = 0.4, end = 1, na.value = \"black\", guide = FALSE)\r\n  scale_colour_manual(values=generateColors(colorRGB0,max(seats)), guide=FALSE, na.value=\"khaki2\")\r\n```\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-32-1.png) \r\n\r\n**Diversity measures: entropy and effective number of parties**\r\n\r\nThe diagrams below show vote disperion an camera dispersion measured with different diversity indexes: Shannon entropy and Laakso-Taagepera effective number of parties.\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-33-1.png) ![](ElectoralSpace_files/figure-html/unnamed-chunk-33-2.png) \r\n\r\n**Largest remainder method with Hare Quota is similar to Voronoi allocation**\r\n\r\nHare quota gives the nearest allocation to each share of votes. Its allocation regions are the Voronoi regions given by the seat allocation nodes:\r\n\r\n\r\n\r\n\r\n```r\r\nalloc <- function(parties, votes, seats, step=1, threshold=0){\r\n  \r\n  #function for Hare Quota seat allocation\r\n  votes=votes*(votes>=(threshold*sum(votes)))\r\n  \r\n  nparties = length(votes)\r\n  \r\n  quota = sum(votes)/seats\r\n  QAllocation = floor(votes/quota)\r\n  rests = votes %% quota\r\n  \r\n  qtable <- data.frame(\r\n    parties = 1:nparties,\r\n    rests,\r\n    votes\r\n  )\r\n  \r\n  if (seats>sum(QAllocation)){\r\n    \r\n    largestRestsParties <- qtable[order(-rests,-votes),]$parties[1:(seats - sum(QAllocation))]\r\n    largestRestsLogic <- is.element(1:nparties, largestRestsParties)\r\n    \r\n  } else {largestRestsLogic <- matrix(F,1,nparties)}\r\n  \r\n  \r\n  Allocation = list(list(QAllocation + largestRestsLogic, matrix(parties[1],seats)))\r\n  #ordering is not taken into account\r\n  \r\n  return(Allocation);\r\n  \r\n}\r\n```\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-36-1.png) ![](ElectoralSpace_files/figure-html/unnamed-chunk-36-2.png) \r\n\r\n```\r\n## [1] 0.004925373\r\n```\r\n\r\n```\r\n## [1] 0.08835821\r\n```\r\n\r\nDifferences are only observed in the boundaries because we have not considered the way ties break when using the distance functions.\r\n\r\n\r\n\r\nHare quota is pretty close to Sainte-Laguë and Droop quota is so to D'Hondt, as can be seen in the next diagrams.\r\n\r\n![](ElectoralSpace_files/figure-html/unnamed-chunk-37-1.png) \r\n\r\n```\r\n## [1] 0.8931343\r\n```\r\n\r\n```\r\n## [1] 0.9232836\r\n```\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}